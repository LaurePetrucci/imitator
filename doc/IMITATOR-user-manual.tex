%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% UNCOMMENT THE LINE BELOW TO VIEW COMMENTS
\def\DraftVersion {}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper,11pt]{report}

% \sloppy

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PACKAGES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[utf8x]{inputenc}

\usepackage[english]{babel} % francais,

\usepackage{fourier}
\usepackage{eulervm}

\usepackage{amsmath,amssymb,amsthm,url}
\usepackage{amsfonts}

% \usepackage{caption}
% \usepackage{subcaption}
% \usepackage{marginnote}

% \usepackage[pdftex]{graphicx,color}
\usepackage[pdftex,
		colorlinks=true,
		pagebackref=true,
		citecolor=darkgreen,
		linkcolor=darkblue,
		urlcolor=darkpurple,
	]{hyperref}

\hypersetup{
	pdftitle={IMITATOR User Manual},
	pdfauthor={\'Etienne Andr\'e}%
}


% BEGIN Watermarking
\ifdefined\DraftVersion
	\usepackage{draftwatermark}
	\SetWatermarkText{draft}
	\SetWatermarkScale{2}
	\SetWatermarkColor[gray]{0.9}
\fi
% END Watermarking


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TIKZ
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{decorations.pathmorphing} 
% Couleurs

\definecolor{darkblue}{rgb}{0, 0, 0.7}
\definecolor{darkgreen}{rgb}{0, 0.5, 0}
\definecolor{darkpurple}{rgb}{0.7, 0, 0.7}


\definecolor{turquoise}{rgb}{0 0.41 0.41}
\definecolor{rouge}{rgb}{0.79 0.0 0.1}
\definecolor{vert}{rgb}{0.15 0.4 0.1}
\definecolor{mauve}{rgb}{0.6 0.4 0.8}
\definecolor{violet}{rgb}{0.58 0. 0.41}
\definecolor{orange}{rgb}{0.8 0.4 0.2}
\definecolor{bleu}{rgb}{0.39, 0.58, 0.93}
\definecolor{gris}{rgb}{0.6,0.6,0.6}
\definecolor{grisfonce}{rgb}{0.4,0.4,0.4}
% Jeu de couleurs pales
\definecolor{cpale1}{rgb}{1, 0.3, 0.3}
\definecolor{cpale2}{rgb}{0.3, 1, 0.3}
\definecolor{cpale3}{rgb}{0.3, 0.3, 1}
\definecolor{cpale4}{rgb}{1, 0.3, 1}
\definecolor{cpale5}{rgb}{1, 1, 0.3}
\definecolor{cpale6}{rgb}{0.3, 1, 1}
\definecolor{cpale7}{rgb}{0.9, 0.6, 0.2}
\definecolor{cpale8}{rgb}{0.7, 0.4, 1}
\definecolor{cpale9}{rgb}{0.5, 1, 0.75}
\definecolor{cpale10}{rgb}{0.8, 0.7, 0.6}
\definecolor{cpale11}{rgb}{0.6, 0.7, 0.8}
\definecolor{cpale12}{rgb}{0.2, 0.5, 0.9}
\definecolor{cpale13}{rgb}{0.5, 0.9, 0.2}
\definecolor{cpale14}{rgb}{0.9, 0.2, 0.5}
\definecolor{cpale15}{rgb}{0.7, 0.7, 0.7}
\definecolor{cpale16}{rgb}{0.8, 0.8, 0.5}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CLEVER REFERENCES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[capitalise,english,nameinlink]{cleveref} % load after algorithm2e and hyperref
% \crefname{line}{\text{line}}{\text{lines}} % to remove the capital


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONSTANTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
% MATHS
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
% Variables
\def\init{\ensuremath{\textsf{init}}} % \xspace
\newcommand{\A}{\mathcal{A}}
\newcommand{\Action}{\ensuremath{\Sigma}}
\newcommand{\action}{a}
\newcommand{\C}{C}
\newcommand{\Cinit}{\C_\init} % initial constraint
\newcommand{\Clock}{X} % set of clocks
\newcommand{\ClockCard}{H} % cardinality of clocks
\newcommand{\clock}{x} % clock
\newcommand{\clockval}{w} % clock valuation
\newcommand{\Cupdates}{\Clock_\mathsf{up}}
\newcommand{\Dupdates}{\DVar_\mathsf{up}}
\newcommand{\dval}{\ensuremath{\delta}} % discrete variable
\newcommand{\DVar}{D} % set of discrete variables
\newcommand{\dvar}{d} % discrete variable
\newcommand{\DVarCard}{J} % cardinality of discrete variables
% \newcommand{\DVarinit}{\DVar_\init} % discrete variable
\newcommand{\edge}{e}
\newcommand{\guard}{g}
\newcommand{\invariant}{I}
\newcommand{\LConstraint}{\mathcal{LC}} % (#1)% set of all constraints over some set
\newcommand{\LConstraintD}{\LConstraint(\DVar)}
\newcommand{\LConstraintXP}{\LConstraint(\Clock \cup \Param)}
\newcommand{\LConstraintXPD}{\LConstraint(\Clock \cup \Param \cup \DVar)}
\newcommand{\lterm}{\mathit{lt}}
\newcommand{\LTerm}{\mathcal{LT}} % (#1)% set of all linear terms over some set
\newcommand{\LTermD}{\LTerm(\DVar)}
\newcommand{\LTermXPD}{\LTerm(\Clock \cup \Param \cup \DVar)}
\newcommand{\loc}{l} % location
\newcommand{\locinit}{\loc_\init}
\newcommand{\Loc}{L} % set of locations
\newcommand{\Param}{P} % set of parameters
\newcommand{\param}{p} % parameter
\newcommand{\ParamCard}{M} % number of parameters
\newcommand{\pval}{v} % parameter valuation
% \newcommand{\resets}{R}
\newcommand{\steps}{ {\rightarrow} }
\newcommand{\stopwatches}{S}
\newcommand{\tuple}[1]{\langle#1\rangle}
\newcommand{\Var}{\mathit{Var}} % set of variables
\newcommand{\var}{\mathit{z}} % variable
\newcommand{\VarCard}{N} % cardinality of variables % TODO: conflict

% Ensembles
\newcommand{\grandb}{{\mathbb B}}
\newcommand{\grandn}{{\mathbb N}}
\newcommand{\grandq}{{\mathbb Q}}
\newcommand{\grandqplus}{{\mathbb Q}_{\geq 0}}
\newcommand{\grandr}{{\mathbb R}}
\newcommand{\grandrplus}{\grandr_{\geq 0}}
\newcommand{\grandz}{{\mathbb Z}}

% Unites
\newcommand{\micros}{\mathit{\mu s}}
\newcommand{\nanos}{ns}

% Noms
\newcommand{\tiling}{\mathit{Tiling}}
% \newcommand{\true}{\mathbf{true}}
\newcommand{\Ko}{K}
\newcommand{\pio}{\pi_0}
\newcommand{\piprime}{\pi}
\newcommand{\To}{T_0}
\newcommand{\Tprime}{T}

% Symboles
\newcommand{\emptystring}{$\epsilon$}
\newcommand{\fleche}[1]{\stackrel{#1}{\rightarrow}}
\newcommand{\Fleche}[1]{\stackrel{#1}{\Rightarrow}}
% \newcommand{\steps}[0]{ {\rightarrow} }

% Booleens
\newcommand{\false}{{\tt false}}
\newcommand{\true}{{\tt true}}

% PARAMETRES RCP
\newcommand{\rcpFMax}{\mathit{rc\_fast\_max}}
\newcommand{\rcpFMin}{\mathit{rc\_fast\_min}}
\newcommand{\rcpSMax}{\mathit{rc\_slow\_max}}
\newcommand{\rcpSMin}{\mathit{rc\_slow\_min}}
\newcommand{\rcpD}{\mathit{delay}}

%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
% ALGORITHMES
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
% Algorithmes PTA
\newcommand{\BC}{\ensuremath{\mathsf{BC}}}
\newcommand{\EFsynth}{\ensuremath{\mathsf{EFsynth}}}
\newcommand{\IM}{\ensuremath{\mathsf{IM}}}
\newcommand{\PRP}{\ensuremath{\mathsf{PRP}}}
\newcommand{\PRPC}{\ensuremath{\mathsf{PRPC}}}


%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
% CONSTANTES DE CHAINES
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%

% Outils
% \newcommand{\apron}{\textsc{Apron}}
\newcommand{\CosyVerif}{\emph{CosyVerif}}
\newcommand{\gdot}{\texttt{dot}}
\newcommand{\graphviz}{Graphviz}
\newcommand{\hytech}{{\sc HyTech}}
% \newcommand{\imitator}{\textsc{Imitator}}
\newcommand{\imitator}{\textsf{IMITATOR}}
\newcommand{\imitatorExec}{\code{imitator}}
\newcommand{\IPTA}{IPTA}
\newcommand{\NIPTA}{NIPTA}
\newcommand{\ocaml}{OCaml}
\newcommand{\phaver}{PHAVer}
% \newcommand{\polka}{NewPolka}
% \newcommand{\prism}{\textsc{Prism}}
% \newcommand{\red}{RED}
\newcommand{\uppaal}{\textsc{Uppaal}}

\newcommand{\binimitator}{./imitator}


% Current version
\newcommand{\imitatorversion}{2.7}
\newcommand{\imitatorversionname}{Butter Guéméné}
	% TODO: add nice picture :-)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THEOREMS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newtheorem{definition}{Definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FORMATING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hyphenation{IMITATOR}
\hyphenation{Uppaal}

\newcommand{\paragraphe}[1]{\paragraph{#1.}}

% Non terminal in a grammar
\newcommand{\nt}[1]{$\langle$\emph{#1}$\rangle$}
% Rule name in a grammar
\newcommand{\regleGrammaire}[1]{\bigskip \noindent \nt{#1} :: \\}
% Not taken into account in the grammar
\newcommand{\npec}[1]{\textcolor{green!50!black}{#1}}

\newcommand{\probleme}[2]{
	\medskip
	\noindent
	\fbox{
		\begin{minipage}{0.95\textwidth}
		\textbf{#1}
		
		#2
		\end{minipage}
	}
	
	\medskip
}

% \newcommand{\commentaire}[1]{\textcolor{red}{\textbf{$\Leftarrow$  #1 $\Rightarrow$}}} % commentaire dans un paragraphe
% \newcommand{\commentaire}[1]{}


% Code integre au texte
\newcommand{\code}[1]{\textbf{\texttt{#1}}}


\definecolor{imicolor}{rgb}{0, .4, .4}
\newcommand{\styleIMI}[1]{\textcolor{imicolor}{\texttt{#1}}}

\definecolor{optioncolor}{rgb}{.4, 0, .4}
\newcommand{\styleOption}[1]{\textcolor{optioncolor}{\texttt{#1}}}
\newcommand{\styleOptionValue}[1]{\textcolor{optioncolor}{\texttt{#1}}}

\definecolor{pathcolor}{rgb}{1, .5, 0}
\newcommand{\stylePath}[1]{\textcolor{pathcolor}{\texttt{#1}}}

\newcommand{\GitHubIMI}{GitHub} % TODO : URL

\newcommand{\styleCommand}[1]{
	\medskip
	
	% \mbox{}\hspace{.5cm}
	\noindent\fcolorbox{white}{black!90}{
		\textcolor{yellow!30}{\$\ \ \texttt{#1}}
	}
	
	\medskip

}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% I.E. / E.G. / W.R.T.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Helps to spot the places where macros are NOT used
\ifdefined \DraftVersion
 	\definecolor{colorok}{RGB}{80,80,150}
\else
	\definecolor{colorok}{RGB}{0,0,0}
\fi

% \newcommand{\eg}{\textcolor{colorok}{\textit{e.g.}}\xspace}
% \newcommand{\ie}{\textcolor{colorok}{\textit{i.e.}}\xspace}
% \newcommand{\wrt}{\textcolor{colorok}{w.r.t.}\xspace}
\newcommand{\adhoc}{\textcolor{colorok}{\textit{ad-hoc} }} % TODO: solve space problems
\newcommand{\eg}{\textcolor{colorok}{\textit{e.g.}, }}
\newcommand{\ie}{\textcolor{colorok}{\textit{i.e.}, }}
\newcommand{\wrt}{\textcolor{colorok}{w.r.t.} }





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% IMITATOR FILES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{listings}
\newcommand{\IncludeIMIfile}[1]{
	\lstset{language=Imitator}
	\lstinputlisting[columns=fixed, numbers=left, numberstyle=\tiny, breaklines=true, breakatwhitespace=true]{#1}
}

\lstdefinelanguage{Imitator}{
	morekeywords={
		and, automaton, clock, discrete, do, end, endreach, False, forward, from, goto, if, in, init, initially, loc, locations, not, or, parameter, print, reach, region, sync, synclabs, True, var, wait, when, while
	},
	sensitive=false,
% 	morecomment=[l][\color{gray}]{--},
	morecomment=[s][keywordstyle]{"}{"},
% 	morecomment=[s]{/*}{*/},
	morecomment=[s][\color{gray!50!blue}]{(*}{*)},
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Title Page
\title{IMITATOR User Manual}
\author{Étienne André}
% \date{}

\begin{document}
% \maketitle

\sloppy


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\thispagestyle{empty}

\mbox{}

\vspace{2cm}

\begin{center}
	{\Huge \bfseries IMITATOR User Manual}

	\vspace{2cm}

	\includegraphics[width=0.40\textwidth]{../logos/imitator-500.png}

	\vspace{2cm}
	
	{\Large Version \imitatorversion{} (\imitatorversionname{})}
	
	\medskip
	
	\includegraphics[width=0.30\textwidth]{../logos/logo2-7-300.png}

\end{center}

\vspace{2cm}

{\small \hfill{}Build \input{../build_number.txt}}

{\small \hfill{}\today{}}

\vspace{2cm}

\begin{center}
 	{\Large \url{www.imitator.fr}}
 	
\end{center}
\hfill\includegraphics[width=.15\textwidth]{images/CC-BY-SA_500.png}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\addcontentsline{toc}{section}{Table of contents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

% \pagestyle{fancyplain}
% \lhead{\fancyplain{}{\imitator{} \imitatorversion{} User Manual}}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\imitator{} is an open source software tool to perform automated parameter synthesis for concurrent timed systems~\cite{AFKS12}.
\imitator{} takes as input a network of \imitator{} parametric timed automata (\NIPTA{}): \NIPTA{} are an extension of parametric timed automata~\cite{AHV93}, a well-known formalism to specify and verify models of systems where timing constants can be replaced with parameters, \ie{} unknown constants.

\imitator{} addresses several variants of the following problem:
``given a concurrent timed system, what are the values of the timing constants that guarantee that the model of the system satisfies some property?''
Specifically, \imitator{} implements parametric safety analysis~\cite{AHV93,JLR15}, the inverse method \cite{ACEF09,AM15}, the behavioral cartography~\cite{AF10}, and parametric reachability preservation~\cite{ALNS15}.
Numerous analysis options are available.

\imitator{} is a command-line only tool, but that can output results in graphical form.
Furthermore, a graphical user interface is available in the \CosyVerif{} platform.

\imitator{} was able to verify numerous case studies from the literature and from the industry, such as communication protocols, hardware asynchronous circuits, schedulability problems and various other systems such as coffee machines (probably the most critical systems from a researcher point of view).
Numerous benchmarks are available at \imitator{} Web page~\cite{imitator}.

In this document, we present the input syntax, we formally define the input model of \imitator{}, and we explain how to perform various analyses using the numerous options.


\paragraph{Keywords:} formal verification, model checking, software verification, parameter synthesis


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{A Brief Introduction to the Syntax}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We first briefly introduce the syntax using a simple example for readers familiar with parametric timed automata, and not interested in subtle details (such as the synchronization model).
A formal (and nearly exhaustive) definition of \imitator{} parametric timed automata (\NIPTA{}) can be found in \cref{section:IPTA}.
The complete syntax is given in \cref{chapter:grammar}.

\paragraphe{Generalities}
The input syntax of \imitator{} is originally based on the syntax of \hytech{}~\cite{HHW95}, with several improvements.
Actually, all standard \hytech{} files describing only PTA (and not more general systems like linear hybrid automata \cite{achh92}) can be analyzed directly by \imitator{} (sometimes with very minor changes).

Comments are OCaml-like comments starting with \styleIMI{(*} and ending with \styleIMI{*)}.
As in OCaml, comments can be nested.


\paragraphe{An example of a coffee machine}
We give below an example of a coffee machine interacting with a researching drinking coffee, given using the \imitator{} syntax.
	% TODO: point to figure

\IncludeIMIfile{../examples/Coffee/coffeeDrinker.imi}

% TODO: add graphic representation, describe model, make at least one call (or even one call per algo)


\paragraphe{Header}
Let us comment this case model by starting with the header.
First, text in comments gives generalities about the model (author, date, description, etc.).
The form is not normalized, but it could be in the future, so it is strongly advised to follow this form.

Then, the variables are declared.


\paragraphe{Automata}
This model contains two \IPTA{}.

\paragraphe{Initial Definitions}







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{IMITATOR Parametric Timed Automata}\label{section:IPTA}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Formal Definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\imitator{} performs parametric verification of models specified using networks of \imitator{} parametric timed automata (hereafter \NIPTA{}).

An \imitator{} parametric timed automaton (hereafter \IPTA{}) is a variant of parametric automata (as introduced in~\cite{AHV93}).
A first difference between \IPTA{} and the PTA of \cite{AHV93} is that \IPTA{} have no accepting / final location;
furthermore, \IPTA{} augment the expressiveness of PTA with several features such as invariants, discrete (integer) variables, complex guards and invariants (\ie{} not only comparing a single clock to a single parameter), stopwatches (\ie{} the ability to stop some clocks in some locations), and arbitrary clock updates (\ie{} not necessarily to~0).

\paragraph{Clocks, Parameters, Discrete Variables}
\emph{Clocks} are real-valued variables all evolving at the same rate (unless they are stopped, which is allowed in \imitator{}).
A set of clocks is $\Clock = \{ \clock_1, \dots, \clock_\ClockCard \}$;
a clock valuation is
$\clockval \colon \Clock \rightarrow \grandrplus$.

\emph{Parameters} are rational-valued variables, that act as unknown constants.
A set of parameters is $\Param = \{ \param_1, \dots, \param_\ParamCard \} $;
a parameter valuation is a function $\pval\colon \Param \rightarrow \grandr$.
We will often identify a valuation~$\pval$ with the \emph{point} $(\pval(\param_1), \dots, \pval(\param_{\ParamCard}))$.

\emph{Discrete variables} are integer-valued variables.
A set of discrete variables is $\DVar = \{ \dvar_1, \dots, \dvar_\DVarCard \} $;
a discrete variable valuation is a function $\dval \colon \DVar \rightarrow \grandn$.


\paragraph{Linear Constraints}
Let us formalize the set of linear constraints allowed in \imitator{}.
Given a set of variables~$\Var = \{ \var_1, \dots, \var_\VarCard \}$ (in the following, this set will be instantiated with $\Clock$ and/or $\Param$ and/or $\DVar$), a \emph{linear term} over $\Var$ is an expression of the form
$$
\sum_{1 \leq i \leq n} \alpha_i \var_i + d
$$
for some $n \in \grandn$,
	where
	$\var_{i} \in \Var$,
	$\alpha_{i} \in \grandq$, for $1 \leq i \leq n$,
	and
	$d \in \grandq$.

An~\emph{atomic constraint} over $\Var$ is an expression of the form
% An \emph{inequality} over $\Clock$ and~$\Param$ is $e \prec 0$, where , and $e$ is a linear term %of the form
$
\lterm \prec 0
$
	where
	$\lterm$ is a linear term over~$\Var$,
	and
	$\prec \in \{<, \leq, \geq, >\}$.

A~\emph{constraint} over $\Var$ is a conjunction of atomic constraints.
We denote by $\LTerm(\Var)$ the set of linear terms over~$\Var$, and by $\LConstraint(\Var)$ the set of constraints over~$\Var$.
In \imitator{}, we will consider constraints belonging to sets such as $\LConstraintXP$ (\ie{} the set of constraints over clocks and parameters), or $\LConstraintXPD$ (\ie{} the set of constraints over clocks, parameters and discrete variables).



\paragraph{\imitator{} Parametric Timed Automata}
We can now give a formal definition of \IPTA{}.

%------------------------------------------------------------
\begin{definition}[\IPTA{}]\label{definition:IPTA}
	An \imitator{} parametric timed automaton (\emph{\IPTA{}}) is a tuple $\A = \tuple{\Action, \Loc, \locinit, \DVar, \Clock, \Param, \invariant, \stopwatches, \steps}$, where:
	\begin{itemize}
		\item $\Action$ is a finite set of actions;
		\item $\Loc$ is a finite set of locations;
		\item $\locinit \in \Loc$ is the initial location;
		\item $\DVar$ is a set of integer-valued variables;
		\item $\Clock$ is a set of clocks;
		\item $\Param$ is a set of parameters;
		\item $\invariant : \Loc \rightarrow \LConstraintXPD$ assigns to every location~$\loc$ a constraint over all variables, called the \emph{invariant} of~$\loc$;
		\item $\stopwatches : \Loc \rightarrow \Clock$ assigns to a every location a list of clocks that are stopped in this location;
		\item $\steps$ is a set of edges $(\loc, \guard, \action, \Cupdates, \Dupdates, \loc')$, where
			$\loc, \loc' \in \Loc$ are the source and destination locations,
			$\guard \in \LConstraintXPD$ is a constraint over all variables (called \emph{guard} of the transition),
			$\action\in\Sigma$ is the action associated with the transition,
			$\Cupdates : \Clock \rightarrow \LTermXPD$ is the update function for clocks, and % TODO: partial function!
			% TODO: sure that we can update to anything??
			$\Dupdates : \DVar \rightarrow \LTermD$ is the update function for discrete variables. % TODO: partial function!
	\end{itemize}
\end{definition}
%------------------------------------------------------------

Observe that clocks can be updated to any value (\ie{} we can assign a clock, not only to~0, but to any linear term over the other clocks, the parameters and the discrete variables.
However, discrete variables can only be assigned to a linear term over~$\DVar$ (including a constant).
If clocks are always reset (\ie{} not assigned to more complex linear terms), \imitator{} will apply some optimizations that (may) increase the analysis speed.
	% TODO: nice box with a ``tip'' title


There are no distinction between clocks and stopwatches.
That is, any clock can potentially be stopped in some location.
\imitator{} will detect whether a model has or not stopwatches; if there is no stopwatch in some model, \imitator{} will apply some optimizations that (may) increase the analysis speed.
	% TODO: nice box with a ``tip'' title


%------------------------------------------------------------
\begin{definition}[\NIPTA{}]
	Given a set of \IPTA{} $\A_i = \tuple{\Action_i, \Loc_i, (\locinit)_i, \DVar_i, \Clock_i, \Param_i, \invariant_i, \stopwatches_i, \steps_i}$, $1 \leq i \leq N$ for some $N \in \grandn$,
	a network of \IPTA{} (\emph{\NIPTA{}}) is a tuple
		$\tuple{\Action, \DVar, \Clock, \Param, \{ \A_i \mid 1 \leq i \leq N \}, \Cinit}$, where:
	\begin{itemize}
		\item $\Action = \bigcup_{1 \leq i \leq N} \Action_i$ is the set of all actions;
		\item $\DVar = \bigcup_{1 \leq i \leq N} \DVar_i$ is the set of all discrete variables;
		\item $\Clock = \bigcup_{1 \leq i \leq N} \Clock_i$ is the set of all clocks;
		\item $\Param = \bigcup_{1 \leq i \leq N} \Param_i$ is the set of all parameters;
		\item $\Cinit \in \LConstraintXPD$ is the initial constraint over $\DVar$, $\Clock$ and $\Param$. % TODO
	\end{itemize}
\end{definition}
%------------------------------------------------------------

Observe that each set of actions, discrete variables, clocks and parameters is not disjoint between all \IPTA{}.
That is, actions, discrete variables, clocks and parameters may be shared between different \IPTA{}.
If a variable is required to be local to an \IPTA{}, then it should just not be used in any other \IPTA{} of the model.

Different from many tools for (parametric) timed automata, clocks are not necessarily initially equal to~0 (this is similar to \hytech{}~\cite{HHW95} but different from \uppaal{}~\cite{LPY97}).
The initial value of the clocks is defined by~$\Cinit$ (see \cref{ss:init}).
If nothing is defined in~$\Cinit$, then their value is supposed to be arbitrary (any real value greater or equal to~0).

Note that parameters are not assumed positive; however, the behavior of \imitator{} has not been tested for negative parameters, and it is strongly advised to constrain them to be positive in $\Cinit$ (if it is not the case, a warning is issued by \imitator{}).

% TODO: example




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Discrete Variables}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Discrete variables\footnote{%
	The name ``discrete variable'' comes from \hytech{}.
}
are global integer-valued variables.
Their value is global, in the sense that they are shared by all \IPTA{} of the model.
They can be seen as syntactic sugar to represent a possibly unbounded number of locations.
	% TODO: how many bits? what happens in case of overflow?

Discrete variables must be initialized to a single constant value in the \styleIMI{init} definition;
if they are not, a warning is issued, and they are arbitrarily set to~0.

Discrete variables can be tested in guards, and updated along transitions.
They are first tested, then updated.
If two \IPTA{} in parallel update the same variable on the same synchronized transition (\eg{} an \IPTA{} performs \styleIMI{i' = 2} while another one performs \styleIMI{i' = 3}), then a warning is issued, and the behavior of the \NIPTA{} becomes unspecified.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Initial State and Initialization of Variables}\label{ss:init}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The definition of the initial state is very permissive in \imitator{}.
Clocks are not necessarily equal to~0, and parameters are not even necessarily positive.

Parameters and clocks can be initially bound by any linear constraint over parameters, clocks, and discrete variables.
That is, we can define initial constraints such as:
\begin{center}
	\styleIMI{x1 + x2 <= 2 p1 + 0.5 p2 - i}.
\end{center}
% TODO: style for sample piece of file
% TODO: check syntax :)

However, discrete variables must be initialized to a \emph{constant integer}.
Given a discrete variable \styleIMI{i}, if the definition of the initial state does not contain an equality of the form \styleIMI{i = ...} followed by a linear term in $\LTermXPD$, then \imitator{} will assume that \styleIMI{i} is initially set to~0, and will issue a warning.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Synchronization Model}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

By default, all \IPTA{} of an \imitator{} model declare their set of actions.\footnote{%
	An alternative is an automatic recognition of the actions used, see option \styleOption{-sync-auto-detect} in \cref{chapter:options}.
}

The \imitator{} synchronization model is such that \emph{all} \IPTA{} declaring an action must synchronize \emph{together} on this action.
This can be seen as a \emph{strong broadcast}.
That is, for a transition labeled with action~\styleIMI{a} to be executed, all \IPTA{} declaring \styleIMI{a} must be ready to execute \styleIMI{a} locally.
Otherwise, this transition cannot be taken (yet).

If an \IPTA{} declares an action \styleIMI{a} that is never used in this \IPTA{}, then action \styleIMI{a} will never be executed in the entire model.\footnote{%
	In this case, \imitator{} will detect this situation and will entirely delete this action from the model, while issuing a warning.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Constants}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\imitator{} does not strictly speaking support global constants (\ie{} a variable the value of which is known once for all).
However, using the syntax
% 
\begin{center}
\styleIMI{c = 2: parameter}
\end{center}
% 
in the definition of the parameters is equivalent to replacing \styleIMI{c} with \styleIMI{2} everywhere in the model.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Parameter Synthesis Using IMITATOR}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


We give here the commands corresponding to the main analysis features of \imitator{}.
We only give the most useful options.
For more detailed commands, and a complete list of options, see \cref{chapter:options}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{State Space Computation}\label{ss:mode:statespace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\imitator{} can compute the entire symbolic state space (``parametric zone graph'').
Of course, the state space may be infinite, and the analysis is not guaranteed to terminate.

The standard command is:

\styleCommand{\binimitator{} model.imi -mode statespace -output-states}

The option \styleOption{-output-states} generates a file with a textual description of all states (without this option, \imitator{} will not output anything).

\imitator{} can also output the trace set in a graphical form using option \styleOption{-output-trace-set}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{EF-Synthesis}\label{ss:mode:EFsynth}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A main problem in parametric timed automata is to compute the set of parameter valuations for which some location (for instance, an error location) is reachable.

The property must be specified as follows, at the end of the model (after the initial state definition):

\styleIMI{property := unreachable loc[AUTOMATON] = LOCATION}\\
where \styleIMI{AUTOMATON} is an automaton name, and \styleIMI{LOCATION} is a location name.

The algorithm \EFsynth{} implemented in \imitator{} is a basic breadth-first procedure, close to the one described in \cite{AHV93,JLR15}.
Of course, the EF-emptiness problem being undecidable~\cite{AHV93}, the analysis is not guaranteed to terminate.

The standard command is:

\styleCommand{\binimitator{} model.imi -mode EFsynth -merge -incl}


The options \styleOption{-merge} and \styleOption{-incl} are optional, but generally greatly increase the analysis efficiency and the termination.
The option \styleOption{-dynamic-elimination} can also be used to reduce the state space.

\imitator{} can also
	output the trace set in a graphical form (option \styleOption{-output-trace-set}),
	output the constraint synthesized in a graphical form in two dimensions (option \styleOption{-output-cart}),
	or
	output the result to a text file (option \styleOption{-output-result}).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Parametric Verification using Properties}\label{ss:mode:prop}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\imitator{} basically only supports bad state reachability synthesis on the one hand, and algorithms such as the inverse method and the cartography on the other hand.
However, many correctness properties can be encoded using reachability using \emph{observers} (see \cite{ABL98,ABBL98,Andre13ICECCS}).

Encoding observers can be done manually (using \adhoc{} \IPTA{}), or using predefined correctness properties commonly met in the literature.

If using a predefined property, the property must be specified as follows, at the end of the model (after the initial state definition):

\styleIMI{property := [PROP]}

\styleIMI{[PROP]} must conform to one of the following patterns, where \styleIMI{AUTOMATON} is an automaton name, \styleIMI{LOCATION} is a location name, \styleIMI{a}, \styleIMI{a1}, \styleIMI{a2} are actions, and the deadline \styleIMI{d} is a (possibly parametric) linear expression:

\begin{itemize}
	\item \styleIMI{property := unreachable loc[AUTOMATON] = LOCATION}
	\item \styleIMI{property := if a2 then a1 has happened before}
	\item \styleIMI{property := everytime a2 then a1 has happened before}
	\item \styleIMI{property := everytime a2 then a1 has happened once before}
% 	\item \styleIMI{property := if a1 then eventually a2}
		% TODO
% 	\item \styleIMI{property := everytime a1 then eventually a2}
		% TODO
% 	\item \styleIMI{property := everytime a1 then eventually a2 once before next}
		% TODO
	\item \styleIMI{property := a within d}
	\item \styleIMI{property := if a2 then a1 has happened within d before}
	\item \styleIMI{property := everytime a2 then a1 has happened within d before}
	\item \styleIMI{property := everytime a2 then a1 has happened once within d before}
	\item \styleIMI{property := if a1 then eventually a2 within d}
	\item \styleIMI{property := everytime a1 then eventually a2 within~d}
	\item \styleIMI{property := if a1 then eventually a2 within d once before next}
	\item \styleIMI{property := sequence a1, \dots, an}
	\item \styleIMI{property := always sequence a1, \dots, an}
\end{itemize}

The semantics of these properties is detailed in~\cite{Andre13ICECCS}.

Then, the command to synthesize parameters is the same as for the EF-synthesis:

\styleCommand{\binimitator{} model.imi -mode EFsynth -merge -incl}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Inverse Method: Trace Preservation}\label{ss:mode:IM}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Given a \NIPTA{} and a reference parameter valuation, the inverse method~\IM{} synthesizes a parameter constraint such that, for any parameter valuation in that constraint, the set of traces is the same as for the reference valuation~\cite{ACEF09}.
This problem is known as the trace preservation synthesis.
The trace-preservation emptiness problem being undecidable~\cite{AM15}, the analysis is not guaranteed to terminate (although it often does in practice).

The command is:

\styleCommand{\binimitator{} model.imi model.pi0}

The reference valuation is described in \stylePath{model.pi0}.

\imitator{} can also
	output the trace set in a graphical form (option \styleOption{-output-trace-set}),
% 	output the constraint synthesized in a graphical form in two dimensions (option \styleOption{-output-cart}),
	% TODO
	or
	output the result to a text file (option \styleOption{-output-result}).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Behavioral Cartography}\label{ss:mode:BC}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Given a \NIPTA{} and a bounded parameter domain, the behavioral cartography~\BC{} synthesizes tiles, \ie{} parameter domains such that for any parameter valuation in that domain, the set of traces is the same~\cite{AF10}.
The corresponding problem being undecidable, the analysis is not guaranteed to terminate; when it terminates, it may also leave ``holes'', \ie{} parameter domains not covered by any tile.
	% TODO: cite AM15

The command is:

\styleCommand{\binimitator{} model.imi model.v0 -mode cover}

The bounded parameter domain is described in \stylePath{model.v0}.

\imitator{} can also
	output all trace sets in a graphical form (option \styleOption{-output-trace-set}),
	output the constraints synthesized in a graphical form in two dimensions (option \styleOption{-output-cart}),
	or
	output the result to a text file (option \styleOption{-output-result}).

The option \styleOption{-step} specifies the interval between any two points of which the coverage is checked (see \cite{AF10}).
By default, it is 1; setting $\frac{1}{3}$ often leads to full coverage when 1 was not enough.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Behavioral Cartography with Random Coverage}\label{sss:mode:BC:random}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

An alternative to the behavioral cartography is a random coverage; it can be seen as a kind of sampling.

The command is:

\styleCommand{\binimitator{} model.imi model.v0 -mode randomXX}

where \styleOption{XX} is the number of times an integer point is randomly selected within the domain defined in \stylePath{model.v0}.
If this point is already covered by one of the tiles, the inverse method is not called, an another point is selected.
Note that \styleOption{XX} represents the number of integer points randomly selected; the number of calls to the inverse method can be significantly smaller.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Parametric Reachability Preservation}\label{ss:mode:PRP}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\imitator{} implements an algorithm solving the following problem:
``given a reference parameter valuation~$\pval$ and some location~$\loc$, synthesize other valuations that preserve the reachability of~$\loc$''.
By preserving the reachability, we mean that $\loc$ is reachable for the other valuations iff $\loc$ is reachable for~$\pval$.

This algorithm~$\PRP$, that combines \EFsynth{} and \IM{} (see~\cite{ALNS15} for details), is called as follows:

\styleCommand{\binimitator{} model.imi model.pi0 -PRP}

Note that a bad location (as in \cref{ss:mode:EFsynth}) or a property (as in \cref{ss:mode:prop}) must be defined in the model.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Parametric Reachability Preservation Cartography}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

An extension of $\PRP$ to the cartography (named \PRPC{}) is also available: \PRPC{} synthesizes parameter constraints in which the (non-)reachability of $\loc$ is uniform.
\PRPC{} was showed in~\cite{ALNS15} to be a good alternative to \EFsynth{}, especially when distributed.

This algorithm~$\PRPC$ is called as follows:

\styleCommand{\binimitator{} model.imi model.v0 -mode cover -PRP}

Again, a bad location (as in \cref{ss:mode:EFsynth}) or a property (as in \cref{ss:mode:prop}) must be defined in the model.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Graphical Output and Translation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Again, we only give the most useful options.
For more detailed commands, and a complete list of options, see \cref{chapter:options}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Trace Set}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To generate the trace set of a given computation in a graphical form, use:

\styleCommand{\binimitator{} model.imi [options] -output-trace-set}

\imitator{} will generate a file \stylePath{model.jpg}.
Note that, beyond about 1,000 states or 1,000 transitions, the \gdot{} utility (responsible to generate the trace set) may crash.

Using \styleOption{-output-trace-set-nodetails} makes a more compact representation (but is also less informative).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Constraints and Cartography}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To generate the constraint generated by \imitator{} in a 2-dimensional plot (using the plot utility), use:

\styleCommand{\binimitator{} model.imi [options] -output-cart}

This will generate file \stylePath{model\_cart\_ef.png} if the algorithm is \EFsynth{},
\stylePath{model\_cart\_bc.png} if the algorithm is \BC{} and its variant,
or \stylePath{model\_cart\_patator.png} if the algorithm is the distributed \BC{} and its variants.

The 2 dimensions chosen for the plot are the first two (non-constant) parameter dimension in the model.

Additional useful options are
\styleOption{-output-cart-x-min},
\styleOption{-output-cart-x-max},
\styleOption{-output-cart-y-min},
\styleOption{-output-cart-y-max}
to tune the values of the axes,
and \styleOption{-output-graphics-source} to keep the plot source.

The graphical output of the constraint is not yet available for the inverse method.
	% TODO


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Export to JPEG}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To generate a graphic representation of the model without performing any analysis, use:

\styleCommand{\binimitator{} model.imi -PTA2JPG}

\imitator{} will generate a file \stylePath{model-pta.jpg}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Export to \LaTeX{}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To generate a \LaTeX{} representation of the model (using the \texttt{tikz} package) without performing any analysis, use:

\styleCommand{\binimitator{} model.imi -PTA2TikZ}

\imitator{} will generate a file \stylePath{model.tex}.
This file is a standalone \LaTeX{} file containing a single figure, which contains the different \IPTA{} in \texttt{subfigure} environments.
The node positioning is not yet supported (locations are depicted vertically), so you may need to manually position all nodes, and bend some transitions if needed.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Inside the Box}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Language and Libraries}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In short, \imitator{} is written in \ocaml{}, and contains about 26,000 lines of code.

\imitator{} makes use of the following external libraries:

\begin{itemize}
	\item The OCaml ExtLib library (Extended Standard Library for Objective Caml);
	\item The GNU Multiple Precision Arithmetic Library (GMP);
	\item The Parma Polyhedra Library (PPL)~\cite{bhz08}, used to compute operations on polyhedra.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Symbolic States}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Verification of timed systems (and specially parametric timed systems) is necessarily done in a symbolic manner, in the sense that the timing information is abstracted by clock constraints.
However, \imitator{} does not perform what is referred to as \emph{symbolic model checking}; in other words, the representation of locations in \imitator{} is explicit.

In short, a symbolic state in \imitator{} is made of the following elements:
\begin{itemize}
	\item the current location (index) of each \IPTA{};
	\item the current value of the (integer-valued) discrete variables;
	\item a constraint on $\Clock \cup \Param \cup \DVar$ representing the continuous information.
\end{itemize}
In \imitator{}, all integers (\ie{} the value of the discrete variables and the coefficients used in the constraints) are unbounded integers (implemented using GMP).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Installation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This document does not aim at explaining how to install \imitator{}.
See the installation files available on the website for the most up-to-date information.

Binaries and source code packages are available on \imitator{}'s Web page~\cite{imitator}.
Note that several standalone binaries are provided online for Linux systems, that require no installation.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{List of Options}\label{chapter:options}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The options available for \imitator{} are explained in the following.

Note that some more options are available in the current implementation of \imitator{}.
If these options are not listed here, they are experimental (or deprecated).
If needed, more information can be obtained by contacting the \imitator{} team.
	% cartonly
	% check-iptta
	% check-point
	% completeIM
	% -counterex


%------------------------------------------------------------
\paragraph{\styleOption{-acyclic} (default: false)}
%------------------------------------------------------------
Does not test if a new state was already encountered.
Without this option, when \imitator{} encounters a new state, it checks if it has been encountered before.
This test may be time consuming for systems with a high number of reachable states.
For acyclic systems, all traces pass only once by a given location.
As a consequence, there are no cycles, so there should be no need to check if a given state has been encountered before.
This is the main purpose of this option.

However, be aware that, even for acyclic systems, several (different) traces can pass by the same state.
In such a case, if the \styleOption{-acyclic} option is activated, \imitator{} will compute \emph{twice} the states after the state common to the two traces.
As a consequence, it is all but sure that activating this option will lead to an increase of speed.

Note also that activating this option for non-acyclic systems may lead to an infinite loop in \imitator{}.


%------------------------------------------------------------
\paragraph{\styleOption{-check-ippta} (default: false)}
%------------------------------------------------------------

Check that every new symbolic state contains an integer point (\ie{} a point in the $\Clock \cup \Param$ dimension).
If not, raises an exception.


%------------------------------------------------------------
\paragraph{\styleOption{-check-point} (default: false)}
%------------------------------------------------------------

In the inverse method, checks at each iteration whether the accumulated parameter constraint is restricted to the reference parameter valuation.
Note that this option is not implemented as nicely as it could be, and can hence turn very costly.


%------------------------------------------------------------
\paragraph{\styleOption{-completeIM} (default: false)}
%------------------------------------------------------------

Returns a complete result for the inverse method for deterministic PTA, \ie{} returns a conjunction of negations of convex parameter constraints.
The result may result in a large list of such constraints, and may hence be complicated to interpret.


%------------------------------------------------------------
\paragraph{\styleOption{-contributors}}
%------------------------------------------------------------
Print the list of contributors and exits.


%------------------------------------------------------------
\paragraph{\styleOption{-depth-limit <limit>} (default: none)}
%------------------------------------------------------------
Limits the depth of the exploration of the state space.
In the cartography mode, this option gives a limit to \emph{each} call to the inverse method.
Setting \styleOption{-depth-limit} guarantees the termination of any execution of \imitator{}, but not the correctness of the algorithms.


%------------------------------------------------------------
\paragraph{\styleOption{-distributed <mode>} (default: not distributed)}
%------------------------------------------------------------
Distributed version of the behavioral cartography.
Various distribution modes are possible:

\begin{description}
	\item[\styleOption{no}] Non-distributed mode (default)
	\item[\styleOption{static}] Static domain decomposition \cite{ACN15}
	\item[\styleOption{sequential}] Master-worker scheme with sequential point distribution \cite{ACE14}
	\item[\styleOption{randomXX}] Master-worker scheme with random point distribution (\eg{}, \styleOption{random5} or \styleOption{random10}); after \styleOption{XX} successive unsuccessful attempts (where the generated point is already covered), the algorithm will switch to an exhaustive sequential iteration \cite{ACE14}
	\item[\styleOption{shuffle}] Master-worker scheme with shuffle point distribution \cite{ACN15}
	\item[\styleOption{dynamic}] Master-worker dynamic subdomain decomposition \cite{ACN15}
\end{description}

% TODO: MPI launch command



%------------------------------------------------------------
\paragraph{\styleOption{-dynamic-elimination} (default: false)}
%------------------------------------------------------------
Dynamic elimination of clocks that are known to not used in the future of the current state~\cite{Andre13FSFMA}.




%------------------------------------------------------------
\paragraph{\styleOption{-fromGrML} (default: false)}
%------------------------------------------------------------

Does not use the standard input syntax described here, but a GrML input syntax.
This is used when interfacing \imitator{} with the \CosyVerif{} platform~\cite{AHHKLLP13}.
Note that, in that case, not all syntactic features of \imitator{} are supported.



%------------------------------------------------------------
\paragraph{\styleOption{-IMK} (default: false)}
%------------------------------------------------------------
Uses a variant of the inverse method that returns a constraint such that no $\pio$-compatible state is reached; it does not guarantee however that any ``good'' state will be reached (see~\cite{AS13}).



%------------------------------------------------------------
\paragraph{\styleOption{-IMunion} (default: false)}
%------------------------------------------------------------
Uses a variant of the inverse method that returns the union of the constraints associated to the last state of each path (see~\cite{AS13}).


%------------------------------------------------------------
\paragraph{\styleOption{-incl} (default: false)}
%------------------------------------------------------------
Consider an inclusion of region instead of the equality when performing the $\textit{Post}$ operation.
In other terms, when encountering a new state, \imitator{} checks if the same state (same location and same constraint) has been encountered before and, if so, discards this ``new'' state.
However, when the \code{-incl} option is activated, it suffices that a previous state with the same location and a constraint \emph{greater than or equal} to the constraint of the new state has been encountered to stop the analysis.
This option corresponds to the way that, \eg{} \hytech{} works, and suffices when one wants to check the \emph{non-reachability} of a given bad state.


%------------------------------------------------------------
\paragraph{\styleOption{-merge} (default: \code{false})}
%------------------------------------------------------------
Use the merging technique of \cite{AFS13atva}.
This option is safe (and advised) for the \EFsynth{} algorithm.

However, not all the properties of the inverse method are preserved when using merging (see \cite{AFS13atva} for details).



%------------------------------------------------------------
\paragraph{\styleOption{-mode} (default: \styleOption{inversemethod})}
%------------------------------------------------------------
The mode for \imitator{}.

\begin{tabular}{@{} l @{\ \ } l}
	\styleOption{statespace} & Generation of the entire parametric state space \\
	& (see \cref{ss:mode:statespace}) \\
	
	\styleOption{EF} & Parametric non-reachability analysis (\EFsynth{} \cite{JLR15}) \\
	& (see \cref{ss:mode:EFsynth}) \\
	
	\styleOption{inversemethod} & Inverse method \\
	& (see \cref{ss:mode:IM}) \\
	
	\styleOption{cover} & Behavioral Cartography Algorithm with full coverage \\
	& (see \cref{ss:mode:BC}) \\
	
	\styleOption{randomXX} & Behavioral Cartography Algorithm with \styleOption{XX} iterations \\
	& (see \cref{sss:mode:BC:random}) \\
\end{tabular}



%------------------------------------------------------------
\paragraph{\styleOption{-no-random} (default: false)}
%------------------------------------------------------------
In the inverse method, no random selection of the $\pio$-incompatible inequality (select the first found).
By default, select an inequality in a random manner.



%------------------------------------------------------------
\paragraph{\styleOption{-output-cart} (default: off)}
%------------------------------------------------------------

After execution of the behavioral cartography or \EFsynth{}, plots the generated zones as a \texttt{.png} file.
This will generate file \stylePath{model\_cart\_ef.png} if the algorithm is \EFsynth{},
\stylePath{model\_cart\_bc.png} if the algorithm is \BC{} and its variant,
or \stylePath{model\_cart\_patator.png} if the algorithm is the distributed \BC{} and its variants.
% This option takes an integer which limits the number of generated plots, where each plot represents the projection of the parametric zones on two parameters.
	% TODO: check
If the model contains more than two parameters, then \code{-output-cart} will plot the projection of the generated zones on the first two parameters of the model (or on the two \emph{varying} parameters in the case of \BC{}).

This option makes use of the external utility \texttt{graph}, which is
part of the \emph{GNU plotting utils}, available on most Linux
platforms.
The generated files will be located in the same directory as the source files, unless option \styleOption{-output-prefix} is used.

Additional useful options are
\styleOption{-output-cart-x-min},
\styleOption{-output-cart-x-max},
\styleOption{-output-cart-y-min},
\styleOption{-output-cart-y-max}
to tune the values of the axes,
and \styleOption{-output-graphics-source} to keep the plot source.


%------------------------------------------------------------
\paragraph{\styleOption{-output-cart-x-min} (default: off)}
%------------------------------------------------------------
Set minimum value for the $x$ axis when plotting the cartography (not entirely functional in all situations yet).

%------------------------------------------------------------
\paragraph{\styleOption{-output-cart-x-max} (default: off)}
%------------------------------------------------------------
Set maximum value for the $x$ axis when plotting the cartography (not entirely functional in all situations yet).

%------------------------------------------------------------
\paragraph{\styleOption{-output-cart-y-min} (default: off)}
%------------------------------------------------------------
Set minimum value for the $y$ axis when plotting the cartography (not entirely functional in all situations yet).

%------------------------------------------------------------
\paragraph{\styleOption{-output-cart-y-max} (default: off)}
%------------------------------------------------------------
Set maximum value for the $y$ axis when plotting the cartography (not entirely functional in all situations yet).



%------------------------------------------------------------
\paragraph{\styleOption{-output-graphics-source} (default: false)}
%------------------------------------------------------------
Keep file(s) used for generating graphical output (\eg{} trace set, cartography); these files are otherwise deleted after the generation of the graphics.


%------------------------------------------------------------
\paragraph{\styleOption{-output-prefix} (default: \stylePath{<input\_file>})}
%------------------------------------------------------------
Set the path prefix for all generated files.
The path can be either relative (to the path to the \binimitator{} binary) or absolute, and must be followed by the file name.

Examples:
\begin{itemize}
	\item \styleOption{-output-prefix log}
	\item \styleOption{-output-prefix ./log}
	\item \styleOption{-output-prefix /home/imitator/outputs}
\end{itemize}


%------------------------------------------------------------
\paragraph{\styleOption{-output-result} (default: false)}
%------------------------------------------------------------
Writes the result of the analysis to a file named \stylePath{<input\_file>.result}.




%------------------------------------------------------------
\paragraph{\styleOption{-output-states} (default: false)}
%------------------------------------------------------------
Generates a file \stylePath{<input\_file>.states} describing the reachable states in plain text (value of the location, of the discrete variables, associated constraint, and its projection onto the parameters).


%------------------------------------------------------------
\paragraph{\styleOption{-output-trace-set} (default: false)}
%------------------------------------------------------------
Graphical output using \gdot{}.
In this case, \imitator{} outputs a file \stylePath{<input\_file>.jpg}, which is a graphical output in the jpg format, generated using \gdot{}, corresponding to the trace set.

Note that the path and the name of those two files can be changed using the \stylePath{-log-prefix} option.


%------------------------------------------------------------
\paragraph{\styleOption{-output-trace-set-nodetails} (default: false)}
%------------------------------------------------------------

In the graphical output of the trace set (see option \styleOption{-output-trace-set}),
does \emph{not} provide detailed information on the local locations of the composed \IPTA{}, and instead only outputs the state id.
Enabling this option may yield a smaller graph, which is useful when generating large trace sets.


%------------------------------------------------------------
\paragraph{\styleOption{-PRP} (default: false)}
%------------------------------------------------------------
Option used to activate \PRP{} or \PRPC{} \cite{ALNS15}.
These options must be used in addition to the \styleOption{-mode} option.
That is, in order to call \PRP{}, use:

\styleCommand{\binimitator{} model.imi model.pi0 -PRP}

And in order to call \PRPC{}, use:

\styleCommand{\binimitator{} model.imi model.v0 -mode cover -PRPC}



%------------------------------------------------------------
\paragraph{\styleOption{-PTA2GrML} (default: false)}
%------------------------------------------------------------
Translates the input model to a GrML format (used by \CosyVerif{} \cite{AHHKLLP13}), and exits.

%------------------------------------------------------------
\paragraph{\styleOption{-PTA2JPG} (default: false)}
%------------------------------------------------------------
Translates the input model to a graphical, human-readable form (in \texttt{.jpg} format), and exits.

%------------------------------------------------------------
\paragraph{\styleOption{-PTA2TikZ} (default: false)}
%------------------------------------------------------------
Translates the input model to a \LaTeX{} representation of the model (using the \texttt{tikz} package) without performing any analysis, and exits.

%------------------------------------------------------------
\paragraph{\styleOption{-states-limit} (default: none)}
%------------------------------------------------------------
Will try to stop after reaching this number of states.
Warning: the program may have to first finish computing the current iteration (\ie{} the exploration of the state space at the current depth) before stopping.


%------------------------------------------------------------
\paragraph{\styleOption{-statistics} (default: false)}
%------------------------------------------------------------
Print info on number of calls to PPL, and other statistics about memory and time.
Warning: enabling this option may slightly slow down the analysis, and will certainly induce some extra computational time at the end.



%------------------------------------------------------------
\paragraph{\styleOption{-step} (default: \styleOption{1})}
%------------------------------------------------------------
Step for the behavioral cartography.
Integers can be used, or rationals (in the form \styleOption{x/y}).

%------------------------------------------------------------
\paragraph{\styleOption{-sync-auto-detect} (default: false)}
%------------------------------------------------------------
\imitator{} considers that all the \IPTA{} declaring a given action must be able to synchronize all together, so that the synchronization can happen.
By default, \imitator{} considers that the actions declared in an \IPTA{} are those declared in the \styleIMI{synclabs} section.
Therefore, if an action is declared but never used in (at least) one \IPTA{}, this label will never be synchronized in the execution\footnote{In such a case, action label is actually completely removed before the execution, in order to optimize the execution, and the user is warned of this removal.}.

The option \styleOption{-sync-auto-detect} allows to detect automatically the actions in each \IPTA{}: the actions declared in the \styleIMI{synclabs} section are ignored, and \imitator{} considers as declared actions only the actions really used in this \IPTA{}.


%------------------------------------------------------------
\paragraph{\styleOption{-time-limit <limit>} (default: none)}
%------------------------------------------------------------
Try to limit the execution time (the value \styleOption{<limit>} is given in seconds).
Note that, in the current version of \imitator{}, the test of time limit is performed at the end of an iteration only (\ie{} at the end of the exploration of the state space at the current depth).
In the cartography mode, this option represents a \emph{global} time limit, not a limit for each call to the inverse method.
	% TODO: really?


%------------------------------------------------------------
\paragraph{\styleOption{-timed} (default: false)}
%------------------------------------------------------------
Add a timing information to each shell output of the program.



%------------------------------------------------------------
\paragraph{\styleOption{-tree} (default: false)}
%------------------------------------------------------------
Does not test if a new state was already encountered.
To be set \emph{only} if the reachability graph is a tree with all states being different (otherwise analysis may loop). 




%------------------------------------------------------------
\paragraph{\styleOption{-verbose} (default: \styleOption{standard})}
%------------------------------------------------------------

Give some debugging information, that may also be useful to have more details on the way \imitator{} works.
The admissible values for \styleOption{-verbose} are given below:

\begin{tabular}{@{} l @{\ \ } l}
 \styleOption{mute} & No output (the result can be output to a file using \styleOption{-output-result}) \\
 \styleOption{warnings} & Prints only warnings \\
 \styleOption{standard} & Give little information (number of steps, computation time)\\
 \styleOption{low} & Give little additional information\\
 \styleOption{medium} & Give quite a lot of information\\
 \styleOption{high} & Give much information\\
 \styleOption{total} & Give really too much information\\
\end{tabular}


%------------------------------------------------------------
\paragraph{\styleOption{-version}}
%------------------------------------------------------------
Prints \imitator{} header including the version number and exits.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Grammar}\label{chapter:grammar}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Variable Names}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A variable name (represented by \styleIMI{<name>} in the grammar below) is a string starting with a letter (small or capital), and followed by a set of letters, digits and underscores (``\styleIMI{\_}'').
By letter we mean the 26 letters of the Latin alphabet, without any diacritic mark.

The set of clock names, parameter names and discrete variable names must (quite naturally) be disjoint.
However, the sets of \IPTA{} names, location names, action names, and variable names are not required to be disjoint.
That is, the same name can be given to a clock, an automaton, an action and a location.

Furthermore, the names of the sets of locations of various \IPTA{} are not-necessarily disjoint either: that is, a same name can be given to two different locations in two different \IPTA{} (and they still represent two different things).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Grammar of the Input File}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The \imitator{} input model is described by the following grammar.
Non-terminals appear \nt{within angled parentheses}.
	% TODO: angled??
A non-terminal followed by two colons is defined by the list of immediately following non-blank lines, each of which represents a legal expansion.
Input characters of terminals appear in \styleIMI{typewritter} font.
The meta symbol \emptystring{} denotes the empty string.

The text \npec{in green} is not taken into account by \imitator{}, but allows some backward-compatibility with \hytech{} files~\cite{HHW95}.


%------------------------------------------------------------
\regleGrammaire{imitator\_input}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \nt{automata\_descriptions} \nt{init} \\
\end{tabular}

\medskip


We define each of those two components below.

%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\subsection{Automata Descriptions}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%

%------------------------------------------------------------
\regleGrammaire{automata\_descriptions}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \nt{declarations} \nt{automata} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{declarations}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \code{var} \nt{var\_lists} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{var\_lists}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \nt{var\_list} \code{:} \nt{var\_type} \code{;} \nt{var\_lists} \\
	$|$ & \emptystring
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{var\_list}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{<name>} \\
	$|$ & \styleIMI{<name> =} \nt{rational} \\
	$|$ & \styleIMI{<name>} \styleIMI{,} \nt{var\_list}\\
	$|$ & \styleIMI{<name> =} \nt{rational} \styleIMI{,} \nt{var\_list}\\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{var\_type}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{clock} \\
	$|$ & \styleIMI{discrete} \\
	$|$ & \styleIMI{parameter} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{automata}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \nt{automaton} \nt{automata} \\
	$|$ & \emptystring \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{automaton}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{automaton} \styleIMI{<name>} \nt{prolog} \nt{locations} \styleIMI{end} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{prolog}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \npec{\nt{initialization}} \nt{sync\_labels} \\
	$|$ & \nt{sync\_labels} \npec{\nt{initialization}} \\
	$|$ & \nt{sync\_labels} \\
	$|$ & \npec{\nt{initialization}} \\
	$|$ & \emptystring \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{\npec{initialization}}
%------------------------------------------------------------
\npec{
\begin{tabular}{l l}
	\  & \styleIMI{initially} \styleIMI{<name>} \nt{state\_initialization} \styleIMI{;} \\
\end{tabular}
}

%------------------------------------------------------------
\regleGrammaire{\npec{state\_initialization}}
%------------------------------------------------------------
\npec{
\begin{tabular}{l l}
	\  & \styleIMI{\&} \nt{convex\_predicate} \\
	$|$ & \emptystring \\
\end{tabular}
}

%------------------------------------------------------------
\regleGrammaire{sync\_labels}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{synclabs} \styleIMI{:} \nt{name\_list} \styleIMI{;} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{name\_list}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \nt{name\_nonempty\_list} \\
	$|$ & \emptystring \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{name\_nonempty\_list}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{<name>} \styleIMI{,} \nt{name\_nonempty\_list} \\
	$|$ & \styleIMI{<name>} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{locations}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \nt{location} \nt{locations} \\
		% TODO / NOTE: costs are allowed there (but not enough implemented)
	$|$ & \emptystring \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{locations}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{loc} \styleIMI{<name>} \styleIMI{:} \styleIMI{while} \nt{convex\_predicate} \nt{stop\_opt} \npec{\nt{wait\_opt}} \nt{transitions} \\
% 	$|$ & \styleIMI{loc} \styleIMI{<name>} \styleIMI{:} \styleIMI{while} \nt{convex\_predicate} \nt{transitions} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{wait\_opt}
%------------------------------------------------------------
\begin{tabular}{l l}
	\ & \npec{\styleIMI{wait()}} \\
	$|$ & \npec{\styleIMI{wait}} \\
	$|$ & \npec{\emptystring} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{stop\_opt}
%------------------------------------------------------------
\begin{tabular}{l l}
	\ & \styleIMI{stop\{} \nt{name\_list} \styleIMI{\}} \\
	$|$ & \emptystring \\
\end{tabular}

	
%------------------------------------------------------------
\regleGrammaire{transitions}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \nt{transition} \nt{transitions} \\
	$|$ & \emptystring \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{transition}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{when} \nt{convex\_predicate} \nt{update\_synchronization} \styleIMI{goto} \styleIMI{<name>} \styleIMI{;} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{update\_synchronization}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \nt{updates} \\
	$|$ & \nt{syn\_label} \\
	$|$ & \nt{updates} \nt{syn\_label} \\
	$|$ & \nt{syn\_label} \nt{updates} \\
	$|$ & \emptystring \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{updates}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{do} \styleIMI{(} \nt{update\_list} \styleIMI{)} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{update\_list}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \nt{update\_nonempty\_list} \\
	$|$ & \emptystring \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{update\_nonempty\_list}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \nt{update} \styleIMI{,} \nt{update\_nonempty\_list} \\
	$|$ & \nt{update} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{update}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{<name>} \styleIMI{'} \styleIMI{=} \nt{linear\_expression} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{syn\_label}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{sync} \styleIMI{<name>} \\
\end{tabular}



%------------------------------------------------------------
\regleGrammaire{convex\_predicate}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{\&} \nt{convex\_predicate\_fol} \\
	$|$ & \nt{convex\_predicate\_fol} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{convex\_predicate\_fol}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \nt{linear\_constraint} \styleIMI{\&} \nt{convex\_predicate} \\
	$|$ & \nt{linear\_constraint} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{linear\_constraint}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \nt{linear\_expression} \nt{relop} \nt{linear\_expression} \\
	$|$ & \styleIMI{True} \\
	$|$ & \styleIMI{False} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{relop}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{<} \\
	$|$ & \styleIMI{<=} \\
	$|$ & \styleIMI{=} \\
	$|$ & \styleIMI{>=} \\
	$|$ & \styleIMI{>} \\
% 	$|$ & \styleIMI{<>} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{linear\_expression}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \nt{linear\_term} \\
	$|$ & \nt{linear\_expression} \styleIMI{+} \nt{linear\_term} \\
	$|$ & \nt{linear\_expression} \styleIMI{-} \nt{linear\_term} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{linear\_term}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \nt{rational} \\
	$|$ & \nt{rational} \styleIMI{<name>} \\
	$|$ & \nt{rational} \styleIMI{*} \styleIMI{<name>} \\
	$|$ & \styleIMI{-} \styleIMI{<name>} \\
	$|$ & \styleIMI{<name>} \\
	$|$ & \styleIMI{(} \nt{linear\_term} \styleIMI{)} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{rational}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \nt{integer} \\
	\  & \nt{float} \\
	$|$ & \nt{integer} \styleIMI{/} \nt{pos\_integer}  \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{integer}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \nt{pos\_integer} \\
	$|$ & \styleIMI{-} \nt{pos\_integer}  \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{pos\_integer}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{<int>} \\
\end{tabular}



%------------------------------------------------------------
\regleGrammaire{float}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \nt{pos\_float} \\
	$|$ & \styleIMI{-} \nt{pos\_float}  \\
\end{tabular}


%------------------------------------------------------------
\regleGrammaire{pos\_float}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{<float>} \\
\end{tabular}


%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\subsection{Initial State}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%

%------------------------------------------------------------
\regleGrammaire{init}
%------------------------------------------------------------
\begin{tabular}{l l}
	& \npec{\nt{init\_declaration}} \nt{init\_definition} \nt{property\_definition} \nt{projection\_definition} \npec{\nt{other\_commands}} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{\npec{init\_declaration}}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \npec{\styleIMI{var} \styleIMI{init} \styleIMI{:} \styleIMI{region} \styleIMI{;}} \\
		% TODO: in fact, any sequence of names is accepted, not only init
	$|$ & \emptystring \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{other\_commands}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{end} \npec{\nt{rest\_of\_commands}} \\
	$|$ & \emptystring \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{\npec{rest\_of\_commands}}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \npec{\nt{anything}} \npec{\nt{rest\_of\_commands}} \\
	$|$ & \emptystring \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{\npec{anything}}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{(} \\
	$|$ & \styleIMI{)} \\
	$|$ & \styleIMI{<name>} \\
	$|$ & \styleIMI{init} \\
	$|$ & \styleIMI{bad} \\
\end{tabular}


%------------------------------------------------------------
\regleGrammaire{init\_definition}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{init} \styleIMI{:=} \nt{region\_expression} \styleIMI{;} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{region\_expression}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{\&} \nt{region\_expression\_fol}\\
	$|$ & \nt{region\_expression\_fol}\\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{region\_expression\_fol}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \nt{state\_predicate} \\
	$|$ & \styleIMI{(} \nt{region\_expression\_fol} \styleIMI{)} \\
	$|$ & \nt{region\_expression\_fol} \styleIMI{\&} \nt{region\_expression\_fol} \\
\end{tabular}


%------------------------------------------------------------
\regleGrammaire{state\_predicate}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{loc} \styleIMI{[} \styleIMI{<name>} \styleIMI{]} \styleIMI{=} \styleIMI{<name>} \\
	$|$ & \nt{linear\_constraint} \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{loc\_predicate}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{loc[} \styleIMI{<name>} \styleIMI{] = \styleIMI{<name>}} \\
\end{tabular}






%------------------------------------------------------------
\regleGrammaire{property\_definition}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{property :=} \nt{pattern} \styleIMI{;} \\
	$|$ & \emptystring \\
\end{tabular}

%------------------------------------------------------------
\regleGrammaire{pattern}
%------------------------------------------------------------
\begin{tabular}{l l}
	\  & \styleIMI{unreachable} \nt{loc\_predicate} \\
	$|$ & \styleIMI{if <name> then <name> has happened before} \\
	$|$ & \styleIMI{everytime <name> then <name> has happened before} \\
	$|$ & \styleIMI{everytime <name> then <name> has happened once before} \\
	$|$ & \styleIMI{if <name> then eventually <name>} \\
	$|$ & \styleIMI{everytime <name> then eventually <name>} \\
	$|$ & \styleIMI{everytime <name> then eventually <name> once before next} \\
	$|$ & \styleIMI{<name> within }\nt{linear\_expression} \styleIMI{} \\
	$|$ & \styleIMI{if <name> then <name> happened within }\nt{linear\_expression} \styleIMI{ before} \\
	$|$ & \styleIMI{everytime <name> then <name> happened within }\nt{linear\_expression} \styleIMI{ before} \\
	$|$ & \styleIMI{everytime <name> then <name> happened once within }\nt{linear\_expression} \styleIMI{ before} \\
	$|$ & \styleIMI{if <name> then eventually <name> within }\nt{linear\_expression} \styleIMI{} \\
	$|$ & \styleIMI{everytime <name> then eventually <name> within }\nt{linear\_expression} \styleIMI{} \\
	$|$ & \styleIMI{everytime <name> then eventually <name> within }\nt{linear\_expression} \styleIMI{ once before next} \\
	$|$ & \styleIMI{sequence} \nt{var\_list} \\
	$|$ & \styleIMI{sequence always} \nt{var\_list} \\
\end{tabular}


%% TODO: add -cartonly grammar ! (entirely removed from the manual so far)

% %------------------------------------------------------------
% \regleGrammaire{loc\_expression}
% %------------------------------------------------------------
% \begin{tabular}{l l}
% 	\  & \nt{loc\_predicate} \\
% 	$|$ & \nt{loc\_predicate} \styleIMI{\&} \nt{loc\_expression} \\
% 	$|$ & \nt{loc\_predicate} \nt{loc\_expression} \\
% \end{tabular}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Grammar of the Reference Valuation File}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The reference valuation file (usually named \stylePath{model.pi0}) gives a constant value to any parameter of the model;
this file is used for~\IM{} and \PRP{}.

It basically consists of a sequence of equalities \styleIMI{parameter = constant} separated (or not!) by the \styleIMI{\&} symbol.
All parameters of the model must be given a valuation in this file; but the file may also use names that do not appear in the model (a warning will just be issued).

Arithmetic expressions (using integers and rationals) can even be used instead of just constants.

% TODO: give the actual grammar


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Grammar of the Reference Hyperrectangle File}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The hyperrectangle file (usually named \stylePath{model.v0}) defines a bounded parameter domain, \ie{} a hyperrectangle having as dimensions the parameters of the model;
this file is used for~\BC{} and \PRPC{}.

It basically consists of a sequence of either equalities \styleIMI{parameter = constant} or intervals \styleIMI{parameter = constant .. constant} separated (or not!) by the \styleIMI{\&} symbol.
All parameters of the model must be given an interval (possibly punctual) in this file; again, the file may also use names that do not appear in the model (a warning will just be issued).

Again, arithmetic expressions (using integers and rationals) can even be used instead of just constants.

% TODO: give the actual grammar


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reserved Words}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The following words are reserved keywords and cannot be used as names for automata, variables, actions or locations. 

\styleIMI{always},
\styleIMI{and},
\styleIMI{automaton},
\styleIMI{bad},
\styleIMI{before},
\styleIMI{carto},
\styleIMI{clock},
\styleIMI{discrete},
\styleIMI{do},
\styleIMI{end},
\styleIMI{eventually},
\styleIMI{everytime},
\styleIMI{False},
% \styleIMI{forward},
% \styleIMI{from},
\styleIMI{goto},
\styleIMI{happened},
\styleIMI{has},
\styleIMI{if},
% \styleIMI{in},
\styleIMI{init},
\styleIMI{initially},
\styleIMI{loc},
\styleIMI{locations},
\styleIMI{next},
\styleIMI{not},
\styleIMI{once},
\styleIMI{or},
\styleIMI{parameter},
\styleIMI{projectresult},
\styleIMI{property},
% \styleIMI{reach},
\styleIMI{region},
\styleIMI{sequence},
\styleIMI{stop},
\styleIMI{sync},
\styleIMI{synclabs},
\styleIMI{then},
\styleIMI{True},
\styleIMI{unreachable},
\styleIMI{var},
\styleIMI{wait},
\styleIMI{when},
\styleIMI{while},
\styleIMI{within}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Missing Features}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Although we try to make \imitator{} as complete as possible, it misses some features, not implemented due to lack of time (contributors are welcome!) or due to complexity, or to keep the tool consistent.
We enumerate in the following what seems to us to be the ``most missing'' features and, when applicable, we give hints to overcome these limitations.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Urgent Locations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Urgent transitions are locations in which time cannot elapse, \ie{} there must be left immediately after being entered.
Whereas this feature is not natively implemented in \imitator{}, it can easily be simulated as follows:
to simulate an urgent location \styleIMI{l}, one can add an extra clock (say \styleIMI{x\_urgent}) initialized to 0 on any transition leading \styleIMI{l}; then, the invariant of \styleIMI{l} is \styleIMI{x\_urgent = 0}.
Note that a single clock \styleIMI{x\_urgent} is enough to simulate any number of urgent locations.

	% TODO: example



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ASAP Transitions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

ASAP (as soon as possible) transitions are transitions that can be taken as soon as all \IPTA{} synchronizing with this transition can execute their local transition.
This is different from urgent transitions, that must be taken in 0 time.
Here, time can elapse, but not after all \IPTA{} are ready to execute their local transition.

This is not supported by \imitator{}, and we do not see a way to simulate it easily.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Parameterized Models}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Parameterized models are understood here as models with an arbitrary number of components (\eg{} Fischer's mutual exclusion protocol with $n$ processes), that would be instantiated (\eg{} $n = 15$) before performing the analysis.
\imitator{} does not currently support such parameterized models, and one should use copy/paste utilities to instantiate $n$ models.
For complicated models with many processes, we usually write short scripts to generate the model (a script \stylePath{CSMACDgenerator.py} to model the varying part of parameterized models for the CSMA/CD case study is available on \GitHubIMI{}).




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Other Synchronization Models}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

One-to-one synchronization could possibly be simulated by using as many transitions as pairs of \IPTA{} in the model, although this may make the model rather complex.

	% TODO: example


Broadcast synchronization (``only the \IPTA{} ready to execute a given transition execute it'') is not supported.
Once more, it could possibly be simulated by using as many transitions as subsets of \IPTA{} in the model, although this will make the model definitely complex.

	% TODO: example


Message passing is not supported.
This can be easily simulated using dedicated discrete variables, that would be read / written in the transition.

	% TODO: example


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Intervals for Discrete Variables}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Discrete variables must be set to a constant integer in the \styleIMI{init} definition (\eg{} \styleIMI{i = 0}).
Setting a variable to an arbitrarily value (\eg{} \styleIMI{i in [0 .. 10]}) is currently not supported.
This can be simulated using an initialization \IPTA{} that nondeterministically sets \styleIMI{i} to any of the values, in 0 time so as to not disturb the model.
	% TODO: example


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Complex Updates for Discrete Variables}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

So far, discrete variables can only be set to linear terms in $\LTermD$;
hence, assigning a discrete variable to a clock, or to a parameter, or to any more complex expression, is not allowed.
A reason for this restriction is that the value of the discrete variables would not anymore be constant (recall that discrete variables are syntactic sugar for \emph{locations}).

However, this can be (partially) simulated with stopwatches: we can replace a discrete variable with a clock that is stopped in all locations (\ie{} it does not evolve with time), and that is updated to the desired value (recall from \cref{definition:IPTA} that the clock updates are more permissive than the discrete variable updates).

% TODO: so far, only d := L(D); impossible to have clocks and parameters due to the constant nature of discrete variables

% TODO: only one PTA/location in the bad state definition




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \newpage
\chapter{Acknowledgments}
% \addcontentsline{toc}{section}{Acknowledgments}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sloppy
\'Etienne André initiated the development of \imitator{} in 2008, and keeps developing it.
Emmanuelle~Encrenaz and Laurent~Fribourg have been great supporters of \imitator{}, on a theoretical point of view, and to find applications both from the literature and real case studies.
Abdelrezzak~Bara provided several examples from the hardware literature.
Jeremy~Sproston provided examples from the probabilistic community.
Bertrand~Jeannet has been of great help on the linking with Apron~\cite{JM09} in a previous version of \imitator{}.
Ulrich~K\"uhne made several important improvements to \imitator{}, and linked the tool to PPL.
Daphne~Dussaud implemented the graphical output of the behavioral cartography.
Romain~Soulat implemented in part the merging technique~\cite{AFS13atva}, and brought several case studies.
Giuseppe~Lipari and Sun~Youcheng provided examples from the real-time systems community, and collaborated on several algorithms.
Camille~Coti, Sami~Evangelista and Nguyen~Hoang~Gia worked on the distributed version of \imitator{}.

% TODO: projects


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Licensing and Credits}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection*{\imitator{} license}
\imitator{} is available under the GNU GPL license.

\begin{center}
	\includegraphics[width=.3\textwidth]{images/GPLv3_Logo.png}
\end{center}

\bigskip

\subsection*{Contributors}
The following people contributed to the development of \imitator{}.


\begin{tabular}{l l @{ } c @{ } l}
	Étienne André & 2008 & -- & \\
	Camille Coti & 2014 & -- & \\
	Daphne Dussaud & 2010 & & \\
	Sami Evangelista & 2014 & & \\
	Ulrich Kühne & 2010 & -- & 2011 \\
	Nguyen Hoang Gia & 2014 & -- & \\
	Romain Soulat & 2010 & -- & 2013 \\
\end{tabular}



\bigskip

\subsection*{User Manual}
This user manual is available under the Creative Commons CC-BY-SA license.

\begin{center}
	\includegraphics[width=.2\textwidth]{images/CC-BY-SA_500.png}
\end{center}

\bigskip

\subsection*{Graphics Credits}
	% TODO: nice tabular showing images

\paragraph{\imitator{}'s logo} comes from \stylePath{Typing monkey.svg} by KaterBegemot on Wikimedia Commons
	(License: Creative Commons Attribution-Share Alike 3.0 Unported).

\url{https://commons.wikimedia.org/wiki/File:Typing_monkey.svg}


\paragraph{\imitator{}'s 2.7 version logo} comes from  \stylePath{Andouille-Scheiben.jpg} by Pwagenblast on Wikimedia Commons
	(License: Creative Commons Attribution 3.0 Unported).
The background erasing was done by Fabrice~Kordon.

\url{https://commons.wikimedia.org/wiki/File:Andouille-Scheiben.jpg}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\bibliographystyle{alpha}
\addcontentsline{toc}{chapter}{References}
\bibliography{biblio}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% BEGIN HACK
\ifdefined\DraftVersion

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Old etc.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\imitator{}~\cite{AFKS12} (for \emph{Inverse Method for Inferring Time AbstracT behaviOR}) is a tool for parameter synthesis in the framework of real-time systems based on the inverse method~$\IM$ for Parametric Timed Automata (PTA) augmented with stopwatches~\cite{AHV93,AM02}.
Different from CEGAR-based methods (see \cite{cgjlv00}), this algorithm for parameter synthesis makes use of a ``good'' parameter valuation~$\pio$ instead of a set of ``bad'' states~\cite{AS13}.

When executing the inverse method, \imitator{} takes as input a network of PTA with stopwatches
and a reference valuation~$\pio$; it synthesizes a constraint~$\Ko$ on the parameters such that (1) $\pio \models \Ko$ and (2) for all parameter valuation~$\piprime$ satisfying $\Ko$, the trace set (\ie{} the discrete behavior) of~$\A$ under~$\piprime$ is the same as for~$\A$ under~$\pio$.
%This preserves in particular linear time properties, 
This provides the system with a criterion of \emph{robustness} (see, e.g., \cite{Markey11})
%, by formally guaranteeing a uniform discrete behavior 
around~$\pio$.

% It , that synchronize on shared actions
% The input syntax, inspired by~\hytech{}, allows the use of clocks (or stopwatches), rational-valued discrete variables, and parameters (i.e. unknown constants) to be used altogether in linear terms, within guards, invariants and updates.

% By iterating the inverse method on all integer points within a bounded reference parameter domain, we get a set of constraints %(``tiles'')
% such that, for every point in each such constraint, the time-abstract behavior is the same: this gives a behavioral cartography of the system~\cite{AF10}.



%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\begin{figure}[ht!]
	% STYLES
	\tikzstyle{etiquette} = [draw=none, color=black]
	
% \tikzstyle{boite}=[text width=8em, text centered, minimum height=2.5em, rounded corners, very thick]
% \tikzstyle{input}=[boite, draw=green!20!gris, top color=green!50, bottom color=green!10!white]
% \tikzstyle{output}=[boite, draw=red!20!gris, top color=red!50, bottom color=red!5!white]
% \tikzstyle{imitator} = [boite, draw=blue!20!gris, text width=10em, minimum height=6em]

	
	\tikzstyle{boite}=[rectangle, draw=black, rounded corners, thick, draw=blue!40!black, top color=blue!5!white, bottom color=blue!20]
% 	\tikzstyle{imitator} = [boite]
% 	\tikzstyle{apron} = [boite, draw=yellow!20!gris, top color=yellow!70, bottom color=yellow!10!white]
% 	\tikzstyle{polka} = [apron]
% 	\tikzstyle{ppl} = [apron]
% 	\tikzstyle{dot} = [boite, draw=purple!20!gris, top color=purple!10!white, bottom color=purple!60]

	\tikzstyle{fleche} = [->, draw=black, semithick]
{

\centering

\begin{tikzpicture}[scale=0.72,  =>stealth']

	% Boites
	\draw[boite] (-5, 5.5) rectangle (-2, 6.5);
	\node [etiquette] at (-3.5, 6) {PTA};
	
	\draw[boite] (-5, 3.8) rectangle (-2, 5);
	\node [etiquette] at (-3.5, 4.4) {\begin{tabular}{c}Reference\\valuation $\pio$\end{tabular}};
	
	\draw[boite] (0, 4) rectangle (6, 6.5);
	\node [etiquette] at (3, 5.25) {\large \imitator{}};
	
% 	\draw[boite] (1, 4) rectangle (5, 5);
% 	\node [etiquette] at (3, 4.5) {PPL};
	
	\draw[boite] (8, 4.5) rectangle (12, 6);
	\node [etiquette] at (10, 5.25) {Constraint $\Ko$};
	
% 	\draw[boite] (8, 4) rectangle (12, 5);
% 	\node [etiquette] at (10, 4.5) {Trace set};

	% Fleches
	\path[fleche] (-2, 6) --++ (2, 0);
	\path[fleche] (-2, 4.4) --++ (2, 0);
% 	\path[fleche] (3.5, 4) --++ (0, -.5);
% 	\path[fleche] (2.5, 3.5) --++ (0, .5);
	\path[fleche] (6, 5.25) --++ (2, 0);
% 	\path[fleche] (6, 4.5) --++ (2, 0);

\end{tikzpicture}

}

\caption{Functional view of \imitator{}}
\label{fig:structure}
\end{figure}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter[Implementation]{General Structure and Implementation} \label{sec:implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Inputs and Outputs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\paragraphe{Inverse Method}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
When calling \imitator{} to apply the inverse method algorithm, the tool takes as input two files, one describing the network of PTA modeling the system, and the other describing the reference valuation.
As depicted in Figure~\ref{fig:ioIM}, it synthesizes a constraint on the parameters solving the inverse problem, as well as optionally the corresponding trace set under a graphical form.
The description of all the parametric reachable states can also be optionally output.

%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\begin{figure}[ht!]
\tikzstyle{input}=[draw, fill=green!40, text width=8em,
    text centered, minimum height=2.5em]
\tikzstyle{output}=[input, fill=red!40]
\tikzstyle{imitator} = [input, text width=10em, fill=blue!40,
    minimum height=6em, rounded corners]
\def\blockdist{2.3}
\def\edgedist{2.5}

{

\centering

\begin{tikzpicture}
    \node (imitator) [imitator] {\imitator{}};

    \path (imitator.162)+(-\blockdist,0) node (input1) [input] {PTA $\A$};
    \path (imitator.-162)+(-\blockdist,0) node (input2) [input] {Reference valuation $\pi_0$};
    \path (imitator.162)+(+3*\blockdist,0) node (output1) [output] {Constraint $K_0$ on the parameters};
    \path (imitator.-162)+(+3*\blockdist,0) node (output2) [output] {Trace set\\(graphical form)};

    \path [draw, ->] (input1) -- (imitator.west |- input1) ;
    \path [draw, ->] (input2) -- (imitator.west |- input2);
    \path [draw, ->] (imitator.east |- output1) -- (output1.west);
    \path [draw, ->] (imitator.east |- output2) -- (output2.west);
\end{tikzpicture}

}

\caption{\imitator{} inputs and outputs in inverse method mode}
\label{fig:ioIM}
\end{figure}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%


%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\paragraphe{Behavioral Cartography Algorithm}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
When calling \imitator{} to apply the behavioral cartography algorithm, the tool takes as an input two files, one describing the network of PTA modeling the system, and the other describing the reference rectangle, \ie{} the bounds to consider for each parameter.
As depicted in Figure~\ref{fig:ioBC}, it synthesizes a list of tiles, as well as optionally the trace set corresponding to each tile under a graphical form.
The description of all the parametric reachable states for each tile may also optionally be output.

%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\begin{figure}[ht!]
\tikzstyle{input}=[draw, fill=green!40, text width=8em,
    text centered, minimum height=2.5em]
\tikzstyle{output}=[input, fill=red!40]
\tikzstyle{imitator} = [input, text width=10em, fill=blue!40,
    minimum height=6em, rounded corners]
\def\blockdist{2.3}
\def\edgedist{2.5}

{

\centering

\begin{tikzpicture}
    \node (imitator) [imitator] {\imitator{}};

    \path (imitator.162)+(-\blockdist,0) node (input1) [input] {PTA $\A$};
    \path (imitator.-162)+(-\blockdist,0) node (input2) [input] {Reference rectangle $V_0$};
    \path (imitator.162)+(+3*\blockdist,0) node (output1) [output] {List of tiles};
    \path (imitator.-162)+(+3*\blockdist,0) node (output2) [output] {List of trace sets\\(graphical form)};

    \path [draw, ->] (input1) -- (imitator.west |- input1) ;
    \path [draw, ->] (input2) -- (imitator.west |- input2);
    \path [draw, ->] (imitator.east |- output1) -- (output1.west);
    \path [draw, ->] (imitator.east |- output2) -- (output2.west);
\end{tikzpicture}

}

\caption{\imitator{} inputs and outputs in behavioral cartography mode}
\label{fig:ioBC}
\end{figure}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%

% 
% %-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
% \paragraphe{Internal Representation}
% %-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
% States are represented using a triple $(q, v, C)$ made of the current location~$q$ in each automaton, a value for each discrete variable\footnote{Discrete variables are syntactic sugar allowing to factorize several locations into a single one. In~\imitator{}, discrete variables are integer variables that can be updated using constants or other discrete variables.}~$v$, and a constraint $C$ on the clocks and the parameters.
% In order to optimize the test of equality between a new computed state and the set of states computed previously, the states are stored in a hash table as follows:
% to a given key $(q, v)$ of the hash table, we associate a list of constraints $C_1, \dots, C_n$, corresponding to the $n$ states $(q, v, C_1)$, \dots, $(q, v, C_n)$.
% % the location and the value for the discrete variables represent the key, and the value corresponds to 
% 
% Note that, unlike \hytech{}, \imitator{} uses exact arithmetics with unlimited precision.
% 
% Contrarily to \hytech{} which performs an \emph{a\,priori} static composition of the automata, thus leading to a dramatical explosion of the number of locations, \imitator{} performs an \emph{on-the-fly} composition of the automata.
% This \emph{on-the-fly} composition allows to analyze bigger systems, and decrease drastically the computation time compared to \imitator{}. % (see \cref{sec:experiments}).

	


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Features} \label{ss:features}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\imitator{} (version \imitatorversion{}) includes the following features:

\begin{itemize}
	\item Analysis of a network of parametric timed automata augmented with stopwatches and discrete rational-valued variables;
	\item Reachability analysis: given a PTA~$\A$, compute the set of all the reachable states (as it is done in tools such as, e.g., \hytech{} and \phaver{});
	\item Inverse method algorithm: given a PTA~$\A$ and a reference valuation~$\pi_0$, synthesize a constraint guaranteeing the same trace set as for $\A[\pi_0]$;
	\item Behavioral cartography algorithm: given a PTA~$\A$ and a rectangular parameter domain~$V_0$, compute a list of tiles. Two different modes can be considered: (1) cover all the integer points of~$V_0$ or, (2) call a given number of times the inverse method on an integer point selected randomly within $V_0$ (which is interesting for rectangles containing a very big number of integer points but few different tiles);
	\item Automatic generation of the trace sets, for the reachability analysis and for both algorithms $\IM$ and $\BC$;
	\item Graphical output of the trace sets;
	\item Graphical output of the behavioral cartography;
	\item Optional use of the merging technique of \cite{AFS12}.
\end{itemize}







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{How to Use \imitator{}} \label{sec:how}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The \imitator{} Input File}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Examples of input files can be found on \imitator{}'s Web page~\cite{imitator}.
A complete example is given in Appendix~\ref{app:source}.
A tentative grammar is given in Appendix~\ref{app:grammar}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Calling \imitator}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\imitator{} can be used with three different modes:

\begin{enumerate}
	\item Reachability analysis: given a PTA~$\A$, compute the whole set of reachable states from a given initial state.
	\item Inverse Method: given a PTA~$\A$ and a valuation~$\pi_0$ of the parameters, compute a constraint on the parameters guaranteeing the same behavior as under~$\pi_0$~\cite{AS13}.
	\item Behavioral Cartography Algorithm: given a PTA~$\A$ and a rectangle~$V_0$ (bounded interval of values for each parameter), compute a cartography of the system~\cite{AF10}.
\end{enumerate}

We detail those three modes below.

% TO DO !
% \commentaire{preciser les sorties et endroits ou les fichiers sont g\'en\'er\'es)}


%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\subsection{Reachability Analysis} \label{ss:mode_reachability}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%

Given a PTA~$\A$, the reachability analysis computes the whole set of reachable states from a given initial state.
The syntax in this case is the following one:

\code{\imitatorExec{} <input\_file> -mode reachability [options]}

Note that there is no need to provide a $\pi_0$ or $V_0$ file in this case (if one is provided, it will be ignored).



%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\subsection{Inverse Method} \label{ss:mode_inversemethod}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%

Given a PTA~$\A$ and a valuation~$\pi_0$ of the parameters, the inverse method compute a constraint $K_0$ on the parameters guaranteeing that, for any $\pi \models K_0$, the trace sets of $\A[\pi]$ and $\A[\pi_0]$ are the same~\cite{AS13}.
The syntax in this case is the following one:

\code{\imitatorExec{} <input\_file> <pi0\_file> [-mode inversemethod] [options]}

Note that the \code{-mode inversemethod} option is not necessary, since the default value for \code{-mode} is precisely \code{inversemethod}.

Note that, unlike the algorithm given in~\cite{AS13}, at a given iteration, the $\pi_0$-incompatible state is selected deterministically, for efficiency reasons.
However, the $\pi_0$-incompatible inequality within a $\pi_0$-incompatible state is selected randomly, unless the \code{-no-random} option is activated.

In this case, \imitator{} outputs the resulting constraint $K_0$ on the standard output.
% Moreover, \imitator{} outputs the same two files as in the reachability analysis.


%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\subsection{Cartography} \label{ss:mode_cartography}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%

Given a PTA~$\A$ and a rectangle~$V_0$ (bounded interval of values for each parameter), the Behavioral Cartography Algorithm computes a cartography of the system~\cite{AF10}.
Two possible variants of the algorithm can be used:
\begin{enumerate}
	\item The standard variant covers all the integer points within $V_0$.
	The syntax in this case is the following one:\\
	\code{\imitatorExec{} <input\_file> <V0\_file> [-mode cover] [options]}

	\item The alternative variant calls the inverse method a certain number of times on a random point $V_0$.
	The syntax in this case is the following one:\\
	\code{\imitatorExec{} <input\_file> <V0\_file> [-mode randomX] [options]}\\
	where \code{X} represents the number of random points to consider.
	If a point has already been generated before, the inverse method is not called.
	If a point belongs to one of the tiles computed before, the inverse method is not called neither.
	Therefore, in practice, the number of tiles generated is smaller than~\code{X}.
\end{enumerate}

When in behavioral cartography mode, one can generate the cartography in a graphical form (for 2 dimensions) using option \code{-cart} (see below).
In that case, an image will be output.

It is also possible to automatically color this cartography (in green and red) according to a property to be verified.
The property must be defined at the end of the \code{.imi} model file, using the following syntax:

\code{property := [PROP]}

\code{[PROP]} must conform to one of the following patterns, where \code{AUTOMATON} is an automaton name, \code{LOCATION} is a location name, \code{a}, \code{a1}, \code{a2} are actions, and the deadline \code{d} is a (possibly parametric) linear expression:

\begin{itemize}
	\item \code{property := unreachable loc[AUTOMATON] = LOCATION}
	\item \code{property := if a2 then a1 has happened before}
	\item \code{property := everytime a2 then a1 has happened before}
	\item \code{property := everytime a2 then a1 has happened once before}
	\item \code{property := if a1 then eventually a2}
	\item \code{property := everytime a1 then eventually a2}
	\item \code{property := everytime a1 then eventually a2 once before next}
	\item \code{property := a within d}
	\item \code{property := if a2 then a1 has happened within d before}
	\item \code{property := everytime a2 then a1 has happened within d before}
	\item \code{property := everytime a2 then a1 has happened once within d before}
	\item \code{property := if a1 then eventually a2 within d}
	\item \code{property := everytime a1 then eventually a2 within~d}
	\item \code{property := if a1 then eventually a2 within d once before next}
	\item \code{property := sequence a1, \dots, an}
	\item \code{property := always sequence a1, \dots, an}
% 	\item \code{}
\end{itemize}






%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\subsection{Examples of Calls}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%

%------------------------------------------------------------
\paragraph{\code{\imitatorExec{} flipflop.imi -mode reachability}}
%------------------------------------------------------------
Computes a reachability analysis on the automata described in file \code{flipflop.imi}.

%------------------------------------------------------------
\paragraph{\code{\imitatorExec{} flipflop.imi -mode reachability -with-dot -with-log}}
%------------------------------------------------------------
Computes a reachability analysis on the automata described in file \code{flipflop.imi}.
Will generate files \code{flipflop.imi.states}, containing the description of the reachable states, and \code{flipflop.imi.jpg} depicting the reachability graph.


%------------------------------------------------------------
\paragraph{\code{\imitatorExec{} flipflop.imi flipflop.pi0}}
%------------------------------------------------------------
Calls the inverse method on the automata described in file \code{flipflop.imi}, and the reference valuation $\pi_0$ given in file \code{flipflop.pi0}.
The resulting constraint $K_0$ will be given on the standard output.
% Moreover, \imitator{} will generate the file \code{flipflop.imi.states}, containing the description of the (parametric) states reachable under $K_0$, and the file \code{flipflop.imi.gif} depicting the reachability graph under any point $\pi \models K_0$.


% %------------------------------------------------------------
% \paragraph{\code{\imitatorExec{} flipflop.imi flipflop.pi0 -no-dot -no-log}}
% %------------------------------------------------------------
% Calls the inverse method on the automata described in file \code{flipflop.imi}, and the reference valuation given in file \code{flipflop.pi0}.
% The resulting constraint will be given on the standard output.
% No file will be generated.


%------------------------------------------------------------
\paragraph{\code{\imitatorExec{} flipflop.imi flipflop.pi0 -with-log -with-parametric-log}}
%------------------------------------------------------------
Calls the inverse method on the automata described in file \code{flipflop.imi}, and the reference valuation $\pi_0$ given in file \code{flipflop.pi0}.
The resulting constraint $K_0$ will be given on the standard output.
and \imitator{} will generate the file \code{flipflop.imi.states}, containing the description of the (parametric) states reachable under $K_0$.
Moveover, for any state in this file, both the constraint on the clocks and the parameters, and the constraint on the parameters will be given.
% \imitator{} will also generate the file \code{flipflop.imi.gif} depicting the reachability graph under any point $\pi \models K_0$.


%------------------------------------------------------------
\paragraph{\code{\imitatorExec{} SRlatch.imi SRlatch.v0 -mode cover}}
%------------------------------------------------------------
Calls the behavioral cartography algorithm on the automata described in file \code{flipflop.imi}, and the rectangle $V_0$ given in file \code{SRlatch.v0}.
The algorithm will cover (at least) all the integer points within $V_0$.
The resulting set of tiles will be given on the standard output.


%------------------------------------------------------------
\paragraph{\code{\imitatorExec{} SRlatch.imi SRlatch.v0 -mode cover -with-dot -with-log}}
%------------------------------------------------------------
Calls the behavioral cartography algorithm on the automata described in file \code{flipflop.imi}, and the rectangle $V_0$ given in file \code{SRlatch.v0}.
The algorithm will cover (at least) all the integer points within $V_0$.
The resulting set of tiles will be given on the standard output.
Given $n$ the number of generated tiles (\ie{} the number of calls to the inverse method algorithm), the program will generate $n$ files of the form \code{SRlatch.imi\_$i$.states} (resp.~$n$ files of the form \code{SRlatch.imi\_$i$.jpg}) giving the description of the states (resp.~the reachability graph) of tile $i$, for $i = 1, \dots, n$.


%------------------------------------------------------------
\paragraph{\code{\imitatorExec{} SRlatch.imi SRlatch.v0 -mode random100 -with-dot}}
%------------------------------------------------------------
Calls the behavioral cartography algorithm on the automata described in file \code{flipflop.imi}, and the rectangle $V_0$ given in file \code{SRlatch.v0}.
The program will call the inverse method on 100 points randomly selected within $V_0$.
Since some points may be generated several times, or some points may belong to previously generated tiles (see \cref{ss:mode_cartography}), the number $n$ of tiles generated will be such that $n \leq 100$.
The program will generate $n$ files of the form \code{SRlatch.imi\_$i$.jpg} giving the reachability graph of tile $i$, for $i = 1, \dots, n$.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Example: SR-latch} \label{sec:example}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\begin{figure}
\centering
\includegraphics[width=0.30\textwidth]{include/SRlatch.pdf}
\ \ \ \ \ \ \ \ 
\begin{tikzpicture}[scale=.25]
	% STYLES
	\tikzstyle{signal} = [line width=1pt,draw=black!80]
	\tikzstyle{doublefleche} = [thin, <->, draw=violet]
	\tikzstyle{pointilles} = [thin, draw=violet, densely dotted]

	\tikzstyle{duree} = [below, pos=0.5, text=violet]

	% NOEUDS
	\node[] at (-1, 5) (S) {$S$};
	\node[] at (-1, 1) (R) {$R$};
	
	% S
	\path[signal]
		(0,6)
		-- ++ (4,0)
		-- ++ (0,-2) 
		-- ++ (12,0)
	;
	\path[doublefleche] (4, 0) -- ++(6, 0) node[duree] {$t^\downarrow$};
	\path[pointilles] (4, 4) -- ++(0, -4);

	% Q
	\path[signal]
		(0,2)
		-- ++ (10,0)
		-- ++ (0,-2) 
		-- ++ (6,0)
	;
\end{tikzpicture}

\caption{SR latch (left) and environment (right)}
\label{fig:srlatch}
\end{figure}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%

We consider a SR-latch described in, e.g., \cite{hh07}, and depicted on Figure~\ref{fig:srlatch} left.
The possible configurations of the latch are the following ones:

\smallskip

{

\centering

\begin{tabular}{|c|c|c|c|}
	\hline
	$S$ & $R$ & $Q$ & $\overline{Q}$ \\
	\hline
	0 & 0 & latch & latch \\
	\hline
	0 & 1 & 0 & 1 \\
	\hline
	1 & 0 & 1 & 0 \\
	\hline
	1 & 1 & 0 & 0 \\
	\hline
\end{tabular}

}

\medskip

We consider an initial configuration with $R = S = 1$ and $Q = \overline{Q} = 0$.
As depicted in Figure~\ref{fig:srlatch}, the signal~$S$ first goes down.
Then, the signal~$R$ goes down after a time~$t^\downarrow$.


We consider that the gate $\mathit{Nor}_1$ (resp. $\mathit{Nor}_2$) has a punctual parametric delay $\delta_1$ (resp. $\delta_2$).
Moreover, the parameter $t^\downarrow$ corresponds to the time duration between the fall of $S$ and the fall of $R$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Parametric Reachability Analysis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We first perform a reachability analysis.
The launch command for \imitator{} is the following one:

\code{\imitatorExec{} SRlatch.imi -mode reachability}

Considering this environment, the trace set of this system is given in Figure~\ref{fig:sr_parametric}, where the states $q_i$, $i = 0, \dots, 6$ correspond to the following values for each signal:

\smallskip

{

\centering

\begin{tabular}{|c||c|c|c|c|}
	\hline
	State & $S$ & $R$ & $Q$ & $\overline{Q}$ \\
	\hline
	$q_0$ & 1 & 1 & 0 & 0 \\
	\hline
	$q_1$ & 0 & 1 & 0 & 0 \\
	\hline
	$q_2$ & 0 & 0 & 0 & 0 \\
	\hline
	$q_3$ & 0 & 1 & 0 & 1 \\
	\hline
	$q_4$ & 0 & 0 & 0 & 1 \\
	\hline
	$q_5$ & 0 & 0 & 1 & 0 \\
	\hline
	$q_6$ & 0 & 0 & 0 & 1 \\
	\hline
\end{tabular}

}

\medskip

% %-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
% \begin{figure}
% \centering
% \footnotesize
% 
% \begin{tikzpicture}[scale=0.45, ->, >=stealth', auto, node distance=1.60cm, thin] % shorten >=1pt, 
%   \tikzstyle{state}=[circle, minimum size=15pt, draw=gris, text=black, inner sep=1.5pt]
% 
% 	\node[state, fill=cpale1] (Q0) at (0,3.5) {$q_0$};
% 	\node[state, fill=cpale2]         (Q1) at (4,2) {$q_1$};
% 	\node[state, fill=cpale3]         (Q2) at (4,5) {$q_2$};
% 	\node[state, fill=cpale4]         (Q3) at (8,0) {$q_3$};
% 	\node[state, fill=cpale5]         (Q4) at (8,2) {$q_4$};
% 	\node[state, fill=cpale5]         (Q5) at (8,5) {$q_5$};
% 	\node[state, fill=cpale6]         (Q6) at (8,8) {$q_6$};
% 	\node[state, fill=cpale7]         (Q7) at (12,2) {$q_7$};
% 	\node[state, fill=cpale7]         (Q8) at (12,0) {$q_8$};
% 	\node[state, fill=cpale8]         (Q9) at (12,4) {$q_9$};
% 	\node[state, fill=cpale7]        (Q10) at (12,6) {$q_{10}$};
% 	\node[state, fill=cpale8]        (Q11) at (12,8) {$q_{11}$};
% 
% 	\path
% 		(Q0) edge [double, below] node {$R^\downarrow$} (Q1)
% 		(Q0) edge [double] node {$S^\downarrow$} (Q2)
% 		(Q1) edge [double, below] node {$Q^\uparrow$} (Q3)
% 		(Q1) edge [double] node {$S^\downarrow$} (Q4)
% 		(Q2) edge [double, below] node {$R^\downarrow$} (Q5)
% 		(Q2) edge [double] node {$\overline{Q}^\uparrow$} (Q6)
% 		(Q3) edge [double] node {$S^\downarrow$} (Q8)
% 		(Q4) edge [double] node {$Q^\uparrow$} (Q7)
% 		(Q5) edge [double, below] node {$\overline{Q}^\uparrow$} (Q9)
% 		(Q5) edge [double] node {$Q^\uparrow$} (Q10)
% 		(Q6) edge [double] node {$R^\downarrow$} (Q11)
% 		;
% 
% \end{tikzpicture}
% \caption{Parametric reachability analysis of the SR latch}
% \label{fig:sr_parametric}
% \end{figure}
% %-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%

%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\begin{figure}
\centering
\footnotesize

\begin{tikzpicture}[scale=0.45, ->, >=stealth', auto, node distance=1.60cm, thin] % shorten >=1pt, 
  \tikzstyle{state}=[circle, minimum size=15pt, draw=gris, text=black, inner sep=1.5pt]

	\node[state, fill=cpale1] (Q0) at (0,2) {$q_0$};
	\node[state, fill=cpale2]         (Q1) at (4,2) {$q_1$};
	\node[state, fill=cpale3]         (Q2) at (8,2) {$q_2$};
	\node[state, fill=cpale4]         (Q3) at (8,4) {$q_3$};
	\node[state, fill=cpale5]         (Q4) at (12,2) {$q_4$};
	\node[state, fill=cpale6]         (Q5) at (12,0) {$q_5$};
	\node[state, fill=cpale5]         (Q6) at (12,4) {$q_6$};

	\path
		(Q0) edge [double] node {$S^\downarrow$} (Q1)
		(Q1) edge [double, below] node {$R^\downarrow$} (Q2)
		(Q1) edge [double] node {$\overline{Q}^\uparrow$} (Q3)
		(Q2) edge [double] node {$\overline{Q}^\uparrow$} (Q4)
		(Q2) edge [double, below] node {$Q^\uparrow$} (Q5)
		(Q3) edge [double] node {$R^\downarrow$} (Q6)
		;

\end{tikzpicture}
\caption{Parametric reachability analysis of the SR latch}
\label{fig:sr_parametric}
\end{figure}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%

% 
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Inverse Method}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% We consider the following reference valuation $\pi_0$ of the parameters:
% 
% {\centering
% 
% \small
% 
% \begin{tabular}{r @{\ =\ } l @{\ \ \ \ \ \ } r @{\ =\ } l @{\ \ \ \ \ \ } r @{\ =\ } l @{\ \ \ \ \ \ } r @{\ =\ } l}
% $\delta_1^-$ & $1$  & $\delta_1^+$ & $4$ & $\delta_2^-$ & $2$ & $\delta_2^+$ & $5$ \\
% $T_R$ & $11$ & $T_S$ & $10$ \\
% \end{tabular}
% 
% }
% 
% Considering this environment and this reference valuation, the trace set is given in Figure~\commentaire{to do}.
% 
% The constraint $K_0$ output by \imitator{} is the following one:
% 
% \smallskip
% 
% {\centering
% 
% %  t_S_down + dNor2_u >= t_R_down + dNor1_l
% %  & dNor1_u >= dNor1_l
% %  & dNor2_u >= dNor2_l
% %  & t_S_down >= 0
% %  & t_R_down > t_S_down
% %  & t_S_down + dNor2_l > t_R_down
% %  & t_R_down + dNor1_u >= t_S_down + dNor2_l
% %  & dNor1_l >= 0
% 
% \small
% \begin{tabular}{r r @{\ } c @{\ } l @{\ \ \ \ \ } r r @{\ } c @{\ } l}
% & $T_S + \delta_2^+ $ & $ \geq $ & $ t_R + \delta_1^- $ &
% $\land$ & $T_S$ & $ \geq $ & $ 0 $ \\
% $\land$ & $T_S + \delta_2^- $ & $>$ & $T_R$ &
% $\land$ & $T_R $ & $>$ & $ T_S $ \\
% $\land$ & $T_R + \delta_1^+ $ & $ \geq $ & $ T_S + \delta_2^- $ &
% $\land$ & $\delta_1^- $ & $ \geq $ & $ 0 $\\
% \end{tabular}
% 
% }
% 
% \medskip
% 
% We checked that the trace sets under the $\pi_0$ and $K_0$ are the same.
% 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Behavioral Cartography Algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Using \imitator{}, we now perform a behavioral cartography of this system.
We consider the following rectangle $V_0$ for the parameters:

\smallskip

{\centering

% \small

\begin{tabular}{r @{\ $\in$ \ } l}
$ t^\downarrow $ & $[0, 10]$ \\
$ \delta_1 $ & $[0, 10]$ \\
$ \delta_2 $ & $[0, 10]$ \\
\end{tabular}

}

\smallskip

The launch command for \imitator{} is the following one:

\code{\imitatorExec{} SRlatch.imi SRlatch.v0 -mode cover}

We get the following six behavioral tiles.
Note that the graphical outputs, automatically generated in the \code{jpg} format by~\imitator{} using the \code{-with-dot} option, were rewritten in \LaTeX{} in this document.


%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\paragraph*{Tile 1.}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
This tile corresponds to the values of the parameters verifying the following constraint:

$$ t^\downarrow = \delta_2
\ \ \land \ \ 
 \delta_1 = 0 $$

The trace set of this tile is given in Figure~\ref{fig:sr_tile_1}.

%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\begin{figure}[ht]
\centering
\footnotesize

\begin{tikzpicture}[scale=0.45, ->, >=stealth', auto, node distance=1.60cm, thin] % shorten >=1pt, 
  \tikzstyle{state}=[circle, minimum size=15pt, draw=gris, text=black, inner sep=1.5pt]

	\node[state, fill=cpale1] (Q0) at (0,2) {$q_0$};
	\node[state, fill=cpale2]         (Q1) at (4,2) {$q_1$};
	\node[state, fill=cpale3]         (Q2) at (8,2) {$q_2$};
	\node[state, fill=cpale4]         (Q3) at (8,4) {$q_3$};
	\node[state, fill=cpale5]         (Q4) at (12,2) {$q_4$};
	\node[state, fill=cpale6]         (Q5) at (12,0) {$q_5$};
	\node[state, fill=cpale5]         (Q6) at (12,4) {$q_6$};

	\path
		(Q0) edge [double] node {$S^\downarrow$} (Q1)
		(Q1) edge [double, below] node {$R^\downarrow$} (Q2)
		(Q1) edge [double] node {$\overline{Q}^\uparrow$} (Q3)
		(Q2) edge [double] node {$\overline{Q}^\uparrow$} (Q4)
		(Q2) edge [double, below] node {$Q^\uparrow$} (Q5)
		(Q3) edge [double] node {$R^\downarrow$} (Q6)
		;

\end{tikzpicture}
\caption{Trace set of tile 1 for the SR latch}
\label{fig:sr_tile_1}
\end{figure}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%

Since $t^\downarrow = \delta_2$, $R^\downarrow$ and $\overline{Q}^\uparrow$ will occur at the same time.
Thus, the order of those two events is unspecified, which explains the choice between going to $q_2$ or $q_3$.
When in state $q_2$, either $Q^\uparrow$ can occur (since $\delta_1 = 0$), in which case the system is stable, or $\overline{Q}^\uparrow$ can occur, which also leads to stability.


%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\paragraph*{Tile 2.}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
This tile corresponds to the values of the parameters verifying the following constraint:

$$ t^\downarrow = \delta_2
\ \ \land \ \ 
\delta_1 > 0 $$

The trace set of this tile is given in Figure~\ref{fig:sr_tile_2}.

%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\begin{figure}[ht]
\centering
\footnotesize

\begin{tikzpicture}[scale=0.45, ->, >=stealth', auto, node distance=1.60cm, thin] % shorten >=1pt, 
  \tikzstyle{state}=[circle, minimum size=15pt, draw=gris, text=black, inner sep=1.5pt]

	\node[state, fill=cpale1] (Q0) at (0,2) {$q_0$};
	\node[state, fill=cpale2]         (Q1) at (4,2) {$q_1$};
	\node[state, fill=cpale3]         (Q2) at (8,2) {$q_2$};
	\node[state, fill=cpale4]         (Q3) at (8,4) {$q_3$};
	\node[state, fill=cpale5]         (Q4) at (12,2) {$q_4$};
% 	\node[state, fill=cpale6]         (Q5) at (12,0) {$q_5$};
	\node[state, fill=cpale5]         (Q6) at (12,4) {$q_6$};

	\path
		(Q0) edge [double] node {$S^\downarrow$} (Q1)
		(Q1) edge [double, below] node {$R^\downarrow$} (Q2)
		(Q1) edge [double] node {$\overline{Q}^\uparrow$} (Q3)
		(Q2) edge [double] node {$\overline{Q}^\uparrow$} (Q4)
% 		(Q2) edge [double, below] node {$Q^\uparrow$} (Q5)
		(Q3) edge [double] node {$R^\downarrow$} (Q6)
		;

\end{tikzpicture}
\caption{Trace set of tile 2 for the SR latch}
\label{fig:sr_tile_2}
\end{figure}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%

Since $t^\downarrow = \delta_2$, $R^\downarrow$ and $\overline{Q}^\uparrow$ will occur at the same time.
Thus, the order of those two events is unspecified, which explains the choice between going to $q_2$ or $q_3$.
When in state $q_2$, $Q^\uparrow$ can not occur (since $\delta_1 > 0$), so $\overline{Q}^\uparrow$ occurs immediately after $R^\downarrow$, which leads to stability.


%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\paragraph*{Tile 3.}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
This tile corresponds to the values of the parameters verifying the following constraint:

$$ \delta_2 > t^\downarrow + \delta_1 $$

The trace set of this tile is given in Figure~\ref{fig:sr_tile_3}.

%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\begin{figure}[ht]
\centering
\footnotesize

\begin{tikzpicture}[scale=0.45, ->, >=stealth', auto, node distance=1.60cm, thin] % shorten >=1pt, 
  \tikzstyle{state}=[circle, minimum size=15pt, draw=gris, text=black, inner sep=1.5pt]

	\node[state, fill=cpale1] (Q0) at (0,2) {$q_0$};
	\node[state, fill=cpale2]         (Q1) at (4,2) {$q_1$};
	\node[state, fill=cpale3]         (Q2) at (8,2) {$q_2$};
% 	\node[state, fill=cpale4]         (Q3) at (8,4) {$q_3$};
% 	\node[state, fill=cpale5]         (Q4) at (12,2) {$q_4$};
	\node[state, fill=cpale6]         (Q5) at (12,2) {$q_5$};
% 	\node[state, fill=cpale5]         (Q6) at (12,4) {$q_6$};

	\path
		(Q0) edge [double] node {$S^\downarrow$} (Q1)
		(Q1) edge [double] node {$R^\downarrow$} (Q2)
% 		(Q1) edge [double] node {$\overline{Q}^\uparrow$} (Q3)
% 		(Q2) edge [double] node {$\overline{Q}^\uparrow$} (Q4)
		(Q2) edge [double] node {$Q^\uparrow$} (Q5)
% 		(Q3) edge [double] node {$R^\downarrow$} (Q6)
		;

\end{tikzpicture}
\caption{Trace set of tile 3 for the SR latch}
\label{fig:sr_tile_3}
\end{figure}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%

In this case, since $\delta_2 > t^\downarrow + \delta_1 $, $S^\downarrow$ will occur before the gate $\mathit{Nor}_2$ has the time to change.
For the same reason, $Q^\uparrow$ will change before $\mathit{Nor}_1$ has the time to change.
With $Q = 1$, the system is now stable: $\mathit{Nor}_1$ does not change.


%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\paragraph*{Tile 4.}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
This tile corresponds to the values of the parameters verifying the following constraint:

% t_down + dNor1 = dNor2                                                                   
%  & dNor2 >= dNor1                                                                           
%  & dNor1 > 0  

$$ t^\downarrow + \delta_1 = \delta_2 \ \ \land \ \ \delta_2 \geq \delta_1 \ \ \land \ \ \delta_1 > 0$$

The trace set of this tile is given in Figure~\ref{fig:sr_tile_4}.

%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\begin{figure}[ht]
\centering
\footnotesize

\begin{tikzpicture}[scale=0.45, ->, >=stealth', auto, node distance=1.60cm, thin] % shorten >=1pt, 
  \tikzstyle{state}=[circle, minimum size=15pt, draw=gris, text=black, inner sep=1.5pt]

	\node[state, fill=cpale1] (Q0) at (0,2) {$q_0$};
	\node[state, fill=cpale2]         (Q1) at (4,2) {$q_1$};
	\node[state, fill=cpale3]         (Q2) at (8,2) {$q_2$};
% 	\node[state, fill=cpale4]         (Q3) at (8,4) {$q_3$};
	\node[state, fill=cpale5]         (Q4) at (12,0) {$q_4$};
	\node[state, fill=cpale6]         (Q5) at (12,2) {$q_5$};
% 	\node[state, fill=cpale5]         (Q6) at (12,4) {$q_6$};

	\path
		(Q0) edge [double] node {$S^\downarrow$} (Q1)
		(Q1) edge [double] node {$R^\downarrow$} (Q2)
% 		(Q1) edge [double] node {$\overline{Q}^\uparrow$} (Q3)
		(Q2) edge [double, below] node {$\overline{Q}^\uparrow$} (Q4)
		(Q2) edge [double] node {$Q^\uparrow$} (Q5)
% 		(Q3) edge [double] node {$R^\downarrow$} (Q6)
		;

\end{tikzpicture}
\caption{Trace set of tile 4 for the SR latch}
\label{fig:sr_tile_4}
\end{figure}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%

Since $t^\downarrow + \delta_1 = \delta_2$, both $Q^\uparrow$ or $\overline{Q}^\uparrow$ can occur.
Once one of them occured, the system gets stable, and no other change occurs.



%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\paragraph*{Tile 5.}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
This tile corresponds to the values of the parameters verifying the following constraint:

% dNor2 > t_down
%  & t_down + dNor1 > dNor2
 
$$ \delta_2 > t^\downarrow
\ \ \land \ \ 
 t^\downarrow + \delta_1 > \delta_2 $$

The trace set of this tile is given in Figure~\ref{fig:sr_tile_5}.

%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\begin{figure}[ht]
\centering
\footnotesize

\begin{tikzpicture}[scale=0.45, ->, >=stealth', auto, node distance=1.60cm, thin] % shorten >=1pt, 
  \tikzstyle{state}=[circle, minimum size=15pt, draw=gris, text=black, inner sep=1.5pt]

	\node[state, fill=cpale1] (Q0) at (0,2) {$q_0$};
	\node[state, fill=cpale2]         (Q1) at (4,2) {$q_1$};
	\node[state, fill=cpale3]         (Q2) at (8,2) {$q_2$};
% 	\node[state, fill=cpale4]         (Q3) at (8,4) {$q_3$};
	\node[state, fill=cpale5]         (Q4) at (12,2) {$q_4$};
% 	\node[state, fill=cpale6]         (Q5) at (12,0) {$q_5$};
% 	\node[state, fill=cpale5]         (Q6) at (12,4) {$q_6$};

	\path
		(Q0) edge [double] node {$S^\downarrow$} (Q1)
		(Q1) edge [double] node {$R^\downarrow$} (Q2)
% 		(Q1) edge [double] node {$\overline{Q}^\uparrow$} (Q3)
		(Q2) edge [double] node {$\overline{Q}^\uparrow$} (Q4)
% 		(Q2) edge [double, below] node {$Q^\uparrow$} (Q5)
% 		(Q3) edge [double] node {$R^\downarrow$} (Q6)
		;

\end{tikzpicture}
\caption{Trace set of tile 5 for the SR latch}
\label{fig:sr_tile_5}
\end{figure}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%

Since $\delta_2 > t^\downarrow$, the gate $\mathit{Nor}_2$ can not change before $R^\downarrow$ occurs.
However, since $t^\downarrow + \delta_1 > \delta_2$, the gate $\mathit{Nor}_2$ changes before $Q^\uparrow$ can occur, thus leading to event~$\overline{Q}^\uparrow$.


%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\paragraph*{Tile 6.}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
This tile corresponds to the values of the parameters verifying the following constraint:

% t_down > dNor2
%  & dNor2 >= 0
%  & dNor1 >= 0
 
$$ t^\downarrow > \delta_2$$

The trace set of this tile is given in Figure~\ref{fig:sr_tile_6}.

%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\begin{figure}[ht]
\centering
\footnotesize

\begin{tikzpicture}[scale=0.45, ->, >=stealth', auto, node distance=1.60cm, thin] % shorten >=1pt, 
  \tikzstyle{state}=[circle, minimum size=15pt, draw=gris, text=black, inner sep=1.5pt]

	\node[state, fill=cpale1] (Q0) at (0,2) {$q_0$};
	\node[state, fill=cpale2]         (Q1) at (4,2) {$q_1$};
% 	\node[state, fill=cpale3]         (Q2) at (8,2) {$q_2$};
	\node[state, fill=cpale4]         (Q3) at (8,2) {$q_3$};
% 	\node[state, fill=cpale5]         (Q4) at (12,2) {$q_4$};
% 	\node[state, fill=cpale6]         (Q5) at (12,0) {$q_5$};
	\node[state, fill=cpale5]         (Q6) at (12,2) {$q_6$};

	\path
		(Q0) edge [double] node {$S^\downarrow$} (Q1)
% 		(Q1) edge [double, below] node {$R^\downarrow$} (Q2)
		(Q1) edge [double] node {$\overline{Q}^\uparrow$} (Q3)
% 		(Q2) edge [double] node {$\overline{Q}^\uparrow$} (Q4)
% 		(Q2) edge [double, below] node {$Q^\uparrow$} (Q5)
		(Q3) edge [double] node {$R^\downarrow$} (Q6)
		;

\end{tikzpicture}
\caption{Trace set of tile 6 for the SR latch}
\label{fig:sr_tile_6}
\end{figure}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%

Since $t^\downarrow > \delta_2$, $\overline{Q}^\uparrow$ occurs before $S^\downarrow$.
The system is then stable.


%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%
\paragraph*{Cartography.}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%

We give in Figure~\ref{fig:sr_cartography} the cartography of the SR latch example.
For the sake of simplicity of representation, we consider only parameters $\delta_1$ and $\delta_2$.
Therefore, we set $t^\downarrow = 1$.

%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%%
\begin{figure}[ht!]
\centering
% \scriptsize
\footnotesize

\begin{tikzpicture}[scale=.20]
	% STYLES
	\tikzstyle{axe} = [line width=1pt, ->, draw=black!80]
% 	\tikzstyle{goodzone} = [line width=2pt, draw=blue!50!black]
	\tikzstyle{v0} = [line width=1pt, draw=black, dashed]

	\tikzstyle{nomzone} = [draw=none, text=black]

	\tikzstyle{fondgris} = [fill=lightgray, draw=none]
	\tikzstyle{zone} = [draw=none]
	\tikzstyle{ligne} = [line width=2pt]

	% AXES
% 	\draw[fondgris] (0, 0) rectangle (3, 3);

	% ZONES
	% 3
	\draw[zone, fill=blue!40!white] (0, 35) -- (0, 10) -- (25, 35) -- cycle;
 	\node[nomzone] at (10, 30) {3};
	% 5
	\draw[zone, fill=green!20!white] (0, 10) -- (25, 35) -- (25, 10) -- cycle;
	\node[nomzone] at (15, 15) {5};
	% 6
	\draw[zone, fill=red!40!white] (0, 0) -- (0, 10) -- (25, 10) -- (25, 0) -- cycle;
	\node[nomzone] at (15, 5) {6};

	% AXES
	\path[axe]
		(0,0) -- ++ (27, 0);
	\path[axe]
		(0,0) -- ++ (0, 37);
	\node at (27, -2) {\large $\delta_1$};
	\node at (-2, 37) {\large $\delta_2$};
	
	% LINES
	% 4
	\draw[ligne, color=red] (0, 10) -- (25, 35);
 	\node[nomzone] at (26, 36) {4};
	% 2
	\draw[ligne, color=blue] (0, 10) -- (25, 10);
 	\node[nomzone] at (26, 10) {2};


	% POINT
	% 1
	\draw[zone, fill=green!50!black] (0,10) circle (.5);
 	\node[nomzone] at (-1, 10) {1};

	% GOOD ZONE
% 	\draw[goodzone]
% 		(8, 6) -- (8, 24) -- (9, 24) -- (27, 6) -- cycle;

	VO
	\path[v0]
		(0, 20) -- ++ (20, 0) -- ++ (0, -20) -- ++ (-20, 0) -- cycle;
	
	% VALEURS
% 	\foreach \x in {0, 1, ..., 40}
% 		\draw (0, \x) -- (-1, \x) node [left] {$\x$};
% 	\foreach \x in {0, 5, ..., 45}
% 		\draw (\x, 0) -- (\x, -1) node [below] {$\x$};
	
\end{tikzpicture}

\caption{Behavioral cartography of the SR latch according to $\delta_1$ and $\delta_2$}
\label{fig:sr_cartography}
\end{figure}
%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%%

Note that tile 1 corresponds to a point, and tiles 2 and 4 correspond to lines.

The rectangle $V_0$ has been represented with dashed lines.
% The number in (or next to) each tile represents the iteration number at which the corresponding constraint was computed during the algorithm run.
Note that all tiles (except tile~1) are unbounded, so that they cover, not only $V_0$, but all the positive real-valued plan.


The source code of this example is available in Appendix~\ref{app:source}.



\newpage

\appendix

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Source Code of the Example} \label{app:source}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Main Input File}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\IncludeIMIfile{include/SRlatch.imi}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{$V_0$ File}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\IncludeIMIfile{include/SRlatch.v0}



\fi
% END HACK


\end{document}

