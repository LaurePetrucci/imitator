--************************************************************--
--************************************************************--
--
--   Fischer's mutual exclusion protocol
--
--   From the PAT version of the protocol
--
--                                Created : 2012/10/08
--                          Last modified : 2012/10/08
--************************************************************--
--************************************************************--

var 
	x1, -- P1's clock
	x2, -- P2's clock
	x3, -- P3's clock
	x4, -- P4's clock
		:clock;
	

	turn,
	counter
		: discrete;

	delta,
	epsilon
		: parameter;
		

	IDLE = -1 -- (constant)
		: parameter; 

(*
--************************************************************--
automaton procGEN
--************************************************************--
synclabs: access_GEN, enter_GEN, check_GEN, finish_GEN, no_access_GEN, turn_GEN, try_GEN;

loc idleGEN: while True wait {}
	when turn = IDLE sync try_GEN do {xGEN' = 0} goto startGEN;

loc startGEN: while xGEN = 0 wait {}
	when xGEN = 0 sync turn_GEN do {turn' = GEN} goto startGENbis;

loc startGENbis: while xGEN <= delta wait {}
	when xGEN >= epsilon sync check_GEN do {xGEN' = 0} goto checkGEN;

loc checkGEN: while xGEN = 0 wait {}
	when turn = GEN sync access_GEN goto accessGEN;
	when turn < GEN sync no_access_GEN goto idleGEN;
	when turn > GEN sync no_access_GEN goto idleGEN; -- oops, no "<>" operator here!

loc accessGEN: while xGEN = 0 wait {}
	when True sync enter_GEN do {counter' = counter + 1} goto CSGEN;

loc CSGEN: while True wait {}
	when True sync finish_GEN do {counter' = counter - 1, turn' = IDLE} goto idleGEN;

end -- procGEN*)


--************************************************************--
automaton proc1
--************************************************************--
synclabs: access_1, enter_1, check_1, finish_1, no_access_1, turn_1, try_1;

loc idle1: while True wait {}
	when turn = IDLE sync try_1 do {x1' = 0} goto start1;

loc start1: while x1 = 0 wait {}
	when x1 = 0 sync turn_1 do {turn' = 1} goto start1bis;

loc start1bis: while x1 <= delta wait {}
	when x1 >= epsilon sync check_1 do {x1' = 0} goto check1;

loc check1: while x1 = 0 wait {}
	when turn = 1 sync access_1 goto access1;
	when turn < 1 sync no_access_1 goto idle1;
	when turn > 1 sync no_access_1 goto idle1; -- oops, no "<>" operator here!

loc access1: while x1 = 0 wait {}
	when True sync enter_1 do {counter' = counter + 1} goto CS1;

loc CS1: while True wait {}
	when True sync finish_1 do {counter' = counter - 1, turn' = IDLE, x1' = 0} goto idle1;

end -- proc1


--************************************************************--
automaton proc2
--************************************************************--
synclabs: access_2, enter_2, check_2, finish_2, no_access_2, turn_2, try_2;

loc idle2: while True wait {}
	when turn = IDLE sync try_2 do {x2' = 0} goto start2;

loc start2: while x2 = 0 wait {}
	when x2 = 0 sync turn_2 do {turn' = 2} goto start2bis;

loc start2bis: while x2 <= delta wait {}
	when x2 >= epsilon sync check_2 do {x2' = 0} goto check2;

loc check2: while x2 = 0 wait {}
	when turn = 2 sync access_2 goto access2;
	when turn < 2 sync no_access_2 goto idle2;
	when turn > 2 sync no_access_2 goto idle2; -- oops, no "<>" operator here!

loc access2: while x2 = 0 wait {}
	when True sync enter_2 do {counter' = counter + 1} goto CS2;

loc CS2: while True wait {}
	when True sync finish_2 do {counter' = counter - 1, turn' = IDLE, x2' = 0} goto idle2;

end -- proc2

--************************************************************--
automaton proc3
--************************************************************--
synclabs: access_3, enter_3, check_3, finish_3, no_access_3, turn_3, try_3;

loc idle3: while True wait {}
	when turn = IDLE sync try_3 do {x3' = 0} goto start3;

loc start3: while x3 = 0 wait {}
	when x3 = 0 sync turn_3 do {turn' = 3} goto start3bis;

loc start3bis: while x3 <= delta wait {}
	when x3 >= epsilon sync check_3 do {x3' = 0} goto check3;

loc check3: while x3 = 0 wait {}
	when turn = 3 sync access_3 goto access3;
	when turn < 3 sync no_access_3 goto idle3;
	when turn > 3 sync no_access_3 goto idle3; -- oops, no "<>" operator here!

loc access3: while x3 = 0 wait {}
	when True sync enter_3 do {counter' = counter + 1} goto CS3;

loc CS3: while True wait {}
	when True sync finish_3 do {counter' = counter - 1, turn' = IDLE, x3' = 0} goto idle3;

end -- proc3


--************************************************************--
automaton proc4
--************************************************************--
synclabs: access_4, enter_4, check_4, finish_4, no_access_4, turn_4, try_4;

loc idle4: while True wait {}
	when turn = IDLE sync try_4 do {x4' = 0} goto start4;

loc start4: while x4 = 0 wait {}
	when x4 = 0 sync turn_4 do {turn' = 4} goto start4bis;

loc start4bis: while x4 <= delta wait {}
	when x4 >= epsilon sync check_4 do {x4' = 0} goto check4;

loc check4: while x4 = 0 wait {}
	when turn = 4 sync access_4 goto access4;
	when turn < 4 sync no_access_4 goto idle4;
	when turn > 4 sync no_access_4 goto idle4; -- oops, no "<>" operator here!

loc access4: while x4 = 0 wait {}
	when True sync enter_4 do {counter' = counter + 1} goto CS4;

loc CS4: while True wait {}
	when True sync finish_4 do {counter' = counter - 1, turn' = IDLE, x4' = 0} goto idle4;

end -- proc4


--************************************************************--
--************************************************************--
-- ANALYSIS
--************************************************************--
--************************************************************--


var 
   init: region;

   
init :=
	----------------------
	-- Initial locations
	----------------------
	& loc[proc1] = idle1
	& loc[proc2] = idle2
	& loc[proc3] = idle3
	& loc[proc4] = idle4
	
	----------------------
	-- Clocks
	----------------------
	& x1 = 0
	& x2 = 0
	& x3 = 0
	& x4 = 0
	
	----------------------
	-- Discrete
	----------------------
	& turn = IDLE
	& counter = 0

	----------------------
	-- Parameters
	----------------------
	-- & epsilon = 3
	-- & delta   = 4
;

