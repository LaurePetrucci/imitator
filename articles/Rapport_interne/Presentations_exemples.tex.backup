\documentclass{article} 
 
\usepackage{pgf} 
\usepackage{tikz} 
\usetikzlibrary{arrows,automata} 
\usepackage[latin1]{inputenc} 
\usepackage{verbatim} 
% \usepackage{rtsched}
\title{Scheduling with IMITATOR: Some Case Studies}
\author{Romain Soulat}
\date{}
\begin{document}
\maketitle


\section{Sketch of the Method illustrated on an example}
\subsection{Instantiated Problem}
In \cite{am02} Abdedda\"{i}m et Maler have shown how to encode the preemptive scheduling using Timed Automata with stopwatches (denoted here by TA). The Job-shop scheduling problem is a generic 
resource allocation problem in which common
resources (``machines'') are required at various time points (and for given duration) by different tasks. The goal is to find a way to allocate the resources such that all the tasks terminate
as soon as possible (or ``minimal makespan'' in the scheduling jargon). We consider a fixed set $M$ of resources. A \emph{step} is a pair $(m,d)$ where $m \in M$ and $d \in \mathcal{N}$, indicating 
the required utilization of resource $m$ for time duration $d$. A \emph{job specification} is a finite sequence
$$J = (m_1,d_1),(m_2,d_2),\cdots, (m_k,d_k)$$ of steps stating that in order to accomplish job $J$, one needs to use a machine $m_1$ for $d_1$ time, then use machine $m_2$ for $d_2$ time etc.
For details, see \cite{am02}.
For example, consider the job-shop problem with 2 jobs on 3 machines defined by $\{J_1, J_2\}$ with $J_1 = (m_1,d_1), (m_2,d_2),(m_3,d_3)$ and $J_2 = (m_2,d'_2)$ with $d_1 = 3, d_2=2, d_3=4, d'_2 = 5$.
There are many possible schedules; two of them are illustrated in Figure. \ref{fig:schedules_maler}.
\begin{figure}[!ht]
 \label{fig:schedules_maler}
 \caption{Schedules}
\end{figure}
The problem is to find a schedule such that the value of the last completed job is minimal. This minimal value is called makespan. There are plenty techniques designed to solve this makespan problem. In 
\cite{am02}, the authors show that the system can be modeled as a product of TAs, each TA corresponding to a job. The makespan problem then reduces to find the shortest path in the product.
As a recapitulation, we have:
\begin{itemize}
 \item Model $M$: A product of TAs
 \item Input $I$:  $\{(m_{i,j},d_{i,j})_{j\in J(i)}\}_{i \in \mathcal{I}}$
 \item Output: $\mu =$ minimal makespan
\end{itemize}

For the example, the makespan is found to be equal to 9.

\subsection{Robustness Analysis}
We first transform the instantiated problem by parametrizing some of the duration values. In the example, we will consider that $d_2$ and $d'_2$ are parameters. We consider accordingly
 the parametric version $\mathcal{PA}$ of the original TA. Besides, we consider the makespan (viz, 9) as an additional input, and we construct a simple test automaton which is composed with $\mathcal{PA}$ in order to test wether or not the 
last job is completed within the makespan.
Finally, we give to IMITATOR as inputs:
\begin{enumerate}
 \item  the automaton resulting from the product of $\mathcal{PA}$ with the test automaton
 \item  an input valuation $\pi_0 = \{d_2=2, d'_2 = 5\}$ for the parameters.
\end{enumerate}
As an output, IMITATOR gives us a constraint $K$ on $d_2, d'_2$ such that: 
\begin{enumerate}
 \item $(2,5) \in K$
 \item the makespan of the system obtained by replacing $d_2, d'_2$ by $v_2, v'_2$ is less than or equal to 9, for all $(v_2,v'_2) \in K$.
\end{enumerate}
On this example K is equal to $ 7 > d'_2 \wedge 3 > d_2 \wedge d'_2 + d_2 \geq 7$.\footnote{There three couples of integer values that satisfy $K$: $(1,6)$, $(2,5)$, $(2,6)$.} This gives us a quantitative
 measure of robustness for the input valuation $\pi_0 = \{d_2=2, d'_2 = 5\}$.
% \section{Presentation of the case studies}

\section{Cyclic Tasks with a given scheduling policy}
\subsection{Context}
In this framework of case studies, we want to prove the schedulability of cyclic tasks on a single machine, we consider the preemptive framework, where a currently running task
can be interrupted by another one when it becomes activated and has a higher priority. Each task $\tau_i$ is defined by an offset $O_i \in \mathcal{N}$ (the time before the first release), 
a period $T_i \in \mathcal{N}$ (the amount of time between two releases), a deadline $D_i \in \mathcal{N} $ (the maximum timed allowed to perform the task) and a Worst Case Execution Time $C_i \in \mathcal{N}$ (the maximum of work required to 
execute the task).

Added to these automata, we have an a priori scheduling policy either Fixed Priority (FP) or Earliest Deadline First (EDF). The first policy gives to each task a priority and when
two tasks are activated at the same time, the computational time is given to the highest priority. The EDF policy gives the computational time to the task that has its deadline coming
the sooner.

In this context, given a scheduler, the system is said to be \emph{schedulable} if each task $\tau_i$ is completed before $D_i$ time units after the beginning of its period. 
Actually because of the periodicity of the problem, we only have to ensure that it is schedulable within $lcm_{i\in \mathcal{I}}(T_i)$.

\subsection{Instantiated Problem}
The problem is the following: given a list of tasks $\{\tau_i\}_{i \in \mathcal{I}}$ $$\tau_i = (O_i,T_i,D_i,C_i),$$ is the system schedulable?\\
\begin{itemize}
 \item Model $M$: A TA per task and a TA for the scheduler
 \item Input $I$: $\{O_i,T_i,D_i,C_i\}_{i \in I}$
 \item Output: Yes/No
\end{itemize}


\subsection{Robustness Analysis}
The problem is parametrized typically by letting deadlines $D_i$s instantiated and parametrizing some of the $C_i$s, $O_i$s and $T_i$s.
\begin{itemize}
 \item Model $M'$: a set of PTA deduced from $M$ by parametrizing the values of interest
 \item Input: $I$ and an identified set of parameters
 \item Output: a constraint $K$ such that for every $\pi \models K$, the $\pi$-instantiated model $M'[\pi]$ is schedulable.
\end{itemize}


% 
% 
% We leave certain values of interest that may be altered by an environment or an adversary as parameters, such as the $C_i$, $O_i$ and $T_i$, to quantify what kind of variations around the reference values does not lead to 
% unschedulability. 
% 
% If the system is schedulable under the reference valuation of the parameters, the constraint output by IMITATOR will guarantee that for every valuation within this constraint, the system is still schedulable.
% Input: $\{O_i,T_i,D_i,C_i\}_{i \in I}$\\
% Output: Yes/No\\
% Model: A TA per task and a TA for the scheduler.
\section{Premptive scheduling on one machine with Fixed Priority and variable execution times \cite{sgl97}}
\subsection{Context}
The problem addressed here is how to determine whether every job in $n$ independent job chains, denoted $J_1, J_2, \cdots, J_n$ can complete in time when the jobs are scheduled on a processor according to a 
priority-driven algorithm. Roughly speaking, we let $J_{i,j}$ denote the $j$th job of the chain $J_i$. Each job $J_{i_j}$ has a fixed priority $\Phi_{i,j}$ and is preemptable. The execution time of $J_{i,j}$ is
in the range $[e^{-}_{i,j},e^{+}_{i,j}]$ with $e^{-}_{i,j},e^{+}_{i,j}$ in $\mathcal{N}$. The release time $r_{i,j}$ of job $J_{i,j}$ is set to an integer value. $J_{i,1}$ is ready for execution at its release time $r_{i,1}$; for each $j > 1$, $J_{i,j}$ cannot
execute until its immediate predecessor $J_{i,j-1}$ completes. For details, see \cite{sgl97}. 
% 
% 
% In this framework of case studies taken from \cite{sgl97}, we want to find the makespan for independant chain of tasks that needs to be done on a single machine.
% Each chain is composed by one or several tasks that need to be done. Each task in a chain cannot
% start until a required amount of time ($r$) has elapsed and until the previous task in the chain has not been completed (except for the first job of every chain). Each task has a Best Case Execution Time (BCET) denoted
%  by $e^{-}$ and a Worst Case Execution Time (WCET) denoted by $e^{+}$. Moreover, since there is only one machine, each task is given a priority $\Phi$ and the machine time is given to the task with the highest priority.
% This way, each chain is a list of tasks and can be given by $(r_{i,j},e^{-}_{i,j},e^{+}_{i,j},\Phi_{i,j})_{i\in I}$
\subsection{Instantiated Problem}
We are given a list of chain of tasks $\{J_i\}_{i \in \mathcal{I}}$ where $J_i = {J_{i,j}}_{j \in \mathcal{J}(i)}$ and $$J_{i,j} = ((r_{i,j},e^{-}_{i,j},e^{+}_{i,j},\Phi_{i,j}).$$
The problem is: what is the minimum time needed to do all the chain of tasks?
\begin{itemize}
 \item Model: A product of TAs, with a TA per task and a TA for the FP scheduler
 \item Input: $I = (r_{i,j},e^{-}_{i,j},e^{+}_{i,j},\Phi_{i,j})_{i\in \mathcal{I}}$
 \item Output: $\Delta =$ Worst case completion time of the last task (of the last chain).
\end{itemize}

\subsection{Robustness Analysis}
The problem is parametrized typically by letting the priorities $\Phi_{i,j}$ and the $[e^{-}_{i,j},e^{+}_{i,j}]$ instantiated as well as the computed value $\Delta$, and by parametrizing some of the $r_i$s.

\begin{itemize}
 \item Model $M'$: a PTA deduced from $M$ by parametrizing the values of interest and composed with a TA that tests wether or not the last task is completed within $\Delta$ (using an error state)
 \item Input: $I$ together with $\Delta$ and an identified set of parameters 
 \item Output: a constraint $K$ such that for every $\pi \models K$, the last task of the $\pi$-instantiated model $M'[\pi]$ is completed within $\Delta$.

\end{itemize}



% 
% For IMITATOR, we take the same list of chain that was used in the original problem and the resulting makespan. We add a very simple automata that checks when every chain has been completed if it has been done in 
% less than the makespan and in this case the automaton goes to a success state, or in more time that required and in this case it goes to an error state.
% We leave certain values of interests that may be altered by an environment or an adversary as parameters, such as the $^{-}_{i,j}, \ e^{+}_{i,j}$ and $r_i$, to quantify what kind of variations around the reference values does not lead to being unschedulable within
% the makespan found for the original problem.
% 
% For any valuation within the constraint output by IMITATOR, there exists a scheduler such that the new makespan is less or equal to the original makespan.

\section{Cyclic Tasks with an FP scheduling policy and an error state \cite{cpr08,lpprc10}}
\subsection{Context}
if S is a periodic
task system, the activation automaton simply consists of a
network of n independent timed automata, each representing
the activation of periodic task $\tau_i$, as shown in Fig. \ref{fig:cyclic_task}; each task $\tau_i$ has a period $T_i$, a fixed duration of time between
two activation events, and it may have an offset $O_i$ for its first activation time. Its activation automaton contains
a clock, which is reset every time the period is reached
and $Release_i$ is fired.
When a job is activated, it executes
for at most a time $C_i$, and has to terminate within the
relative deadline $D_i$. The activation of jobs can be modeled by a parametric
timed automaton, where activation events are associated with transition labels, see Fig. \ref{fig:cyclic_task}.

A Fixed Priority scheduler automaton is added to these tasks. When the time
elapsed from the last activation of a task equals to its deadline
time and the total demanded time exceeds the length of
the interval, the task misses the deadline and the automaton reaches an error state. For details see n \cite{cpr08}.


\begin{figure}[!ht]
\centering
\label{fig:cyclic_task}
% \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=6cm, 
%                     semithick] 
%     \tikzstyle{every state}=[fill=white,draw=black,text=black, text width = 1.33cm]
%    \tikzstyle{every edge}=[draw = black, text width = 4cm] 
%    \node[state] (I)                    {Init\\$t <= O$};
%    \node[state] (A)        [right of= I]            {idle\\$t <= T$};
%   \node[state]         (B) [right of=A]        {waiting/running\\$t <= T$}; 
%    
%    \path (A) edge [bend left=3]    node {$t = T$\ \\Require \ \\$t:= 0$} (B)
%          (B) edge [bend left=3]    node {Done } (A)
% 	 (I) edge [bend left=60]	 node {$t = O$\ \\Require \ \\$t:= 0$} (B);
% \end{tikzpicture}
 \caption{Automaton for a periodic task with an offset}
\end{figure}
We say that the system is \emph{schedulable} if each task $\tau_i$ is completed before its relative deadline $D_i$. Actually, because of the periodicity
of the system, we only have to be sure that it is schedulable within $lcm_{i\in I}(T_i)$.
% In this framework of case studies as presented in \cite{cpr08,lpprc10}, we want to prove the schedulability of cyclic tasks on a single machine. Each task is defined by an offset (the time before the first release), 
% a period (the amount of time between two releases), a deadline (the maximum timed allowed to perform the task) and a Worst Case Execution Time (the maximum of work required to 
% execute the task). These parameters are respectively denoted by $O$, $T$, $D$ and $C$. The main difference between this framework and the one in section I is that multiple occurence of the same task can 
% be active at the same time.
% 
% A Fixed Priority scheduler automata is added to these tasks. It has an error state, where it can go if the deadline is met and the required amount of work had not been performed.
% 
% The problem is said to be schedulable if there is a way to schedule tasks such that every task is accomplished during its own period and before its deadline.

\subsection{Instantiated Problem}
We are given a list of tasks $\{\tau_i\}_{i \in \mathcal{I}}$ with $$\tau_i=(O_i,T_i,D_i,C_i).$$ 
The problem is: is the system schedulable? 
\begin{itemize}
 \item Model $M$: A TA per task and a TA for the scheduler
 \item Input $I$: $\{O_i,T_i,D_i,C_i\}_{i \in I}$
 \item Output: Yes or No
\end{itemize}



\subsection{Robustness Analysis}
% We leave certain values of interests that may be altered by an environment or an adversary as parameters, such as the $C_i$, $O_i$ and $T_i$, to quantify what kind of variations around the reference values does not lead to 
% unschedulability. 
% If the system is schedulable under the reference valuation of the parameters, the constraint output by IMITATOR will guarantee that for every valuation within this constraint, the system is still schedulable.


The problem is parametrized typically by letting the deadlines $D_i$s instantiated and by parametrizing some of the $C_i$s, $O_i$s and $T_i$s.
\begin{itemize}
 \item Model $M'$: a PTA deduced from $M$ by parametrizing the values of interest 
 \item Input: $I$ and an identified set of parameters
 \item Output: a constraint $K$ such that for every $\pi \models K$, the $\pi$-instantiated model $M'[\pi]$ is schedulable.
\end{itemize}


\section{Premptive Job-Shop Scheduling with multiple machines \cite{am02}}
\subsection{Context}
The Job-shop scheduling problem is a generic resource allocation problem in which common
resources (``machines'') are required at various time points (and for given duration) by different tasks. The goal is to find a way to allocate the resources such that all the tasks terminate
as soon as possible (or ``minimal makespan'' in the scheduling jargon). We consider a fixed set $M$ of resources. A \emph{step} is a pair $(m,d)$ where $m \in M$ and $d \in \mathcal{N}$, indicating 
the required utilization of resource $m$ for time duration $d$. A \emph{job specification} is a finite sequence
$$J = (m_1,d_1),(m_2,d_2),\cdots, (m_k,d_k)$$ of steps stating that in order to accomplish job $J$, one needs to use a machine $m_1$ for $d_1$ time, then use machine $m_2$ for $d_2$ time etc. For details, see \cite{am02}.
% 
% In this framework of case studies presented in \cite{am02}, we want to find the makespan for independant chain of tasks that needs to be done on a several machines.
% Each chain is composed by one or several tasks that need to be done. Each task of the chain has a WCET (denoted by $C$). When two tasks try to work on the same machine, one has to preempt the other one. There is 
% no a priori scheduling policy so everything is possible.
% This way, each chain is a list of tasks and can be given by a list of couples $(m_i,C_i)$ where $m$ is the machine on which the task has to performed and $C$ the required amount of time to be spent on this machine
% in order to move to the next task.

\subsection{Instantiated Problem}
We are given a list of job specifications $\{J_i\}_{i \in \mathcal{I}}$ where $$J_i =\{(m_{i,j},d_{i,j})\}_{j \in J(i)}.$$ 
The problem is: What is the minimal makespan to complete all the chain of tasks?
\begin{itemize}
 \item Model $M$: A product of TAs, with a TA per job
 \item Input $I$:  $\{(m_{i,j},d_{i,j})_{i\in I(j)}\}_{j \in J}$
 \item Output: $\mu =$ minimal makespan
\end{itemize}


\subsection{Robustness Analysis}
The problem is parametrized typically by parametrizing some of the $d_i$s.


\begin{itemize}
 \item Model $M'$: a PTA deduced from $M$ by parametrizing the values of interest and composed with a TA that tests wether or not the last task is completed within $\mu$ (using an ok and an error state)\\
 \item Input: $I$ together with an identified set of parameters and the value of the computed makespan $\mu$ \\
 \item Output: a constraint $K$ such that for every $\pi \models K$, there is a schedule which allows to complete the last task of the $\pi$-instantiated model $M'[\pi]$ within $\mu$.
\end{itemize}

\section{Schedulability Analysis with Behavioral Cartography}
When one is only interested in finding all the parameters valuation such that the system is schedulable, without considering a particular schedule, it is interesting to consider the Behavioral Cartography Method
included in IMITATOR. 
 By iterating $IM$ over all the integers points %(or each step given by a rational value, e.g., $1/3$)
inside a finite but dense rectangle $V_0$ in the parametric space, one is able to decompose (most of) the parametric space included into $V_0$ into behavioral tiles\footnote{Actually, one can take a finer discretization step than integers to ensure a better coverability of~$V_0$}~\cite{af10}.

For a given tile, we ensure that for every valuation of the parameters in this tile, the behavior of $\mathcal{A}$ is the same;
therefore, we only have to test the schedulability of a single point for each tile to ensure the schedulability on the whole tile.

Let us apply this method on a ``Rate monotonic'' example of \cite[Section~III]{bb04}.
There are three periodic tasks $\tau_1, \tau_2$ and $\tau_3$ with periods of $T_1 = 3, \ T_2 = 8$ and $T_3 = 20$ and deadlines of $D_1 = 3, \ D_2 = 8$ and $D_3 = 20$.
We are interested in finding the set of computation times of each task such that the system is schedulable.
(The interested reader can find the full details in \cite{bb04}.)

We set $V_0$ as $C_1 \in [0,3]$, $C_2 \in [0,8]$ and $C_3 \in [0,20]$, where $C_i$ is the computational time of $\tau_i$. The system is unschedulable if there exists a task $\tau_i$ such that $C_i > T_i$. 
% We recall the algorithm for $\BC$, we first pick an integer point $\pi_k$ that does not belong to any tile already computed and we synthesize $\IM(\A,\pi_k)$ which will be a new tile. We iterate this process 
% until no integer point remains uncover (since $V_0$ only contains a finite number of integer points, we know that GC will terminate in a finite number of iterations).
Algorithm~$BC$ outputs the set of tiles and we check for one point of each tile whether the system is schedulable or not.
The result for this example is given in Figures \ref{fig:carto1}, \ref{fig:carto2}, \ref{fig:carto3} for this $V_0$ with a discretization step of $0.2$.

\begin{figure}[!ht]
	\centering
% 	\includegraphics[scale = 0.5]{./figures/C1-C2.png}
	\caption{Cartography output by IMITATOR 2.5 (in green the system is schedulable; in red, unschedulable)}
	\label{fig:carto}
\end{figure}

\begin{figure}[!ht]
	\centering
% 	\includegraphics[scale = 0.5]{./figures/C1-C2.png}
	\caption{Cartography output by IMITATOR 2.5 (in green the system is schedulable; in red, unschedulable)}
	\label{fig:carto}
\end{figure}

\begin{figure}[!ht]
	\centering
% 	\includegraphics[scale = 0.5]{./figures/C1-C2.png}
	\caption{Cartography output by IMITATOR 2.5 (in green the system is schedulable; in red, unschedulable)}
	\label{fig:carto}
\end{figure}
\bibliographystyle{plain}
\bibliography{biblio}
\section{Results}
\begin{figure}[!ht]
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
Case Study & $|\mathcal{A}|$ & $|\mathcal{X}|$ & $|\mathcal{P}|$ & $|s|$ & $|T|$ & $n$ & $|\mathcal{K}|$ & $t$ (s) \\
\hline
[AM02] 	&3&	3& 	4& 	53& 	70& 	10& 	5& 	0.45\\
\hline 
[LA02] 2$\times$5	&3&	3&	11&	371&	528&	21&	10&	63.4\\
\hline
[LA02] 3$\times$5&	4&	3&	16&	4903&	9043&	30&	5	&160.6\\
\hline
[SGL97]		 &8& 	15& 	18& 	215& 	264& 	15& 	17& 	85.3\\
\hline
[CPR08] &4 &	6 &	8 &	676& 	886& 	15& 	15& 	288.3\\
\hline
[HPPR10] &3 &	4 &	9 &	60& 	103& 	10& 	7& 	2.1\\
\hline
[BB04]	&5&	7&	10&	\_&	\_&	\_&	\_&	66\\
\hline
\end{tabular}
\caption{Results for the schedulability problem}
\end{figure}
The examples have been executed with the following commands:
\begin{itemize}
 \item HYMITATOR case\_study.imi case\_study.pi0 -merge for [AM02], [SGL97], [CPR08] and [HPPR10]
 \item HYMITATOR case\_study.imi case\_study.pi0 -merge -inclusion for [LA02] 2*5 and [LA02] 3*5
 \item HYMITATOR case\_study.imi case\_study.v0 -mode cover -merge -step 0.2 for the cartography of [BB04]
\end{itemize}

\end{document}
