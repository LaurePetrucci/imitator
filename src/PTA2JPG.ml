(************************************************************
 *
 *                     IMITATOR
 * 
 * Laboratoire Specification et Verification (ENS Cachan & CNRS, France)
 * Author:        Etienne Andre
 * Created:       2012/08/24
 * Last modified: 2015/07/30
 *
 ************************************************************)


open Exceptions
open AbstractModel
open CamlUtilities



(************************************************************
 Functions
************************************************************)

(* Create the array of dot colors *)
let dot_colors = Array.of_list Graphics.dot_colors

(* Coloring function for each thing *)
let color = fun index ->
	(* If more colors than our array: white *)
	try dot_colors.(index) with Invalid_argument _ -> "white"


let id_of_location automaton_index location_index =
	"s_" ^ (string_of_int automaton_index) ^ "_" ^ (string_of_int location_index)

let string_of_list_of_variables variable_names variables =
	let variables = List.map variable_names variables in
	string_of_list_of_string_with_sep "," variables

	
(* Add a header to the model *)
let string_of_header model =
	(* Retrieve the input options *)
	let options = Input.get_options () in
	          "/************************************************************"
	^ "\n" ^" * File automatically generated by " ^ Constants.program_name ^ ""
	^ "\n" ^" * Version  : " ^ (ImitatorUtilities.program_name_and_version_and_nickname_and_build())
	^ "\n" ^" * Model    : '" ^ options#file ^ "'"
	^ "\n" ^" * Generated: " ^ (now()) ^ ""
	^ "\n" ^" ************************************************************/"
	

(* Convert a sync into a string *)
let string_of_sync model action_index =
	match model.action_types action_index with
	| Action_type_sync -> (model.action_names action_index) ^ "\\n"
	| Action_type_nosync -> ""


let string_of_clock_updates model = function
	| No_update -> ""
	| Resets list_of_clocks -> 
		string_of_list_of_string_with_sep "\\n" (List.map (fun variable_index ->
			(model.variable_names variable_index)
			^ ":=0"
		) list_of_clocks)
	| Updates list_of_clocks_lt -> 
		string_of_list_of_string_with_sep "\\n" (List.map (fun (variable_index, linear_term) ->
			(model.variable_names variable_index)
			^ ":="
			^ (LinearConstraint.string_of_pxd_linear_term model.variable_names linear_term)
		) list_of_clocks_lt)

	
(* Convert a list of updates into a string *)
let string_of_updates model updates =
	string_of_list_of_string_with_sep "\\n" (List.map (fun (variable_index, linear_term) ->
		(* Convert the variable name *)
		(model.variable_names variable_index)
		^ ":="
		(* Convert the linear_term *)
		^ (LinearConstraint.string_of_pxd_linear_term model.variable_names linear_term)
	) updates)


(* Convert a transition of a location into a string *)
let string_of_transition model automaton_index source_location action_index (guard, clock_updates, discrete_updates, destination_location) =
(* s_12 -> s_5 [label="bUp"]; *)
	"\n\t"
	(* Source *)
	^ (id_of_location automaton_index source_location)
	(* Destination *)
	^ " -> "
	^ (id_of_location automaton_index destination_location)
	
	^ " ["
	(* Color for sync label *)
	(* Check if the label is shared *)
	^ (if List.length (model.automata_per_action action_index) > 1 then
		let color = color action_index in
		"style=bold, color=" ^ color ^ ", "
		else "")
	(* LABEL *)
	^ "label=\""
	(* Guard *)
	^ (
		if not (LinearConstraint.pxd_is_true guard) then
			(escape_string_for_dot (LinearConstraint.string_of_pxd_linear_constraint model.variable_names guard)) ^ "\\n"
		else ""
		)
	(* Sync *)
	^ (string_of_sync model action_index)
	(* Clock updates *)
	^ (string_of_clock_updates model clock_updates)
	(* Add a \n in case of both clocks and discrete *)
	^ (if clock_updates != No_update && discrete_updates != [] then "\\n" else "")
	(* Discrete updates *)
	^ (string_of_updates model discrete_updates)
	^ "\"];"
	
	(* Convert the guard *)
(* 	^ (LinearConstraint.string_of_linear_constraint model.variable_names guard) *)
	(* Convert the updates *)
(* 	^ " do {" *)
(* 	^ (string_of_clock_updates model clock_updates) *)
	
	
(*	^ (string_of_updates model discrete_updates)
	^ "} "
	(* Convert the sync *)
	^ (string_of_sync model action_index)
	(* Convert the destination location *)
	^ " goto " ^ (model.location_names automaton_index destination_location)
	^ ";"*)


(* Convert the transitions of a location into a string *)
let string_of_transitions model automaton_index location_index =
	string_of_list_of_string (
	(* For each action *)
	List.map (fun action_index -> 
		(* Get the list of transitions *)
		let transitions = model.transitions automaton_index location_index action_index in
		(* Convert to string *)
		string_of_list_of_string (
			(* For each transition *)
			List.map (string_of_transition model automaton_index location_index action_index) transitions
			)
		) (model.actions_per_location automaton_index location_index)
	)


(* Convert a location of an automaton into a string *)
let string_of_location model automaton_index location_index =	
(* 	s_0[fillcolor=red, style=filled, shape=Mrecord, label="s_0|{InputInit|And111|Or111}"]; *)
	"\n"
	(* Id *)
	^ (id_of_location automaton_index location_index) ^ "["
	(* Color *)
	^ "fillcolor=" ^ (if model.is_urgent automaton_index location_index then "red" else "paleturquoise2") (*(color location_index)*) ^ ", style=filled, fontsize=16"
	
	(* Label: start *)
	^ ", label=\""
	(* Label: urgency *)
	^ (if model.is_urgent automaton_index location_index then "U |" else "")
	(* Label: name *)
	^ (model.location_names automaton_index location_index)
	(* Label: invariant *)
	^ "|{" ^ (escape_string_for_dot (LinearConstraint.string_of_pxd_linear_constraint model.variable_names (model.invariants automaton_index location_index)))
	(* Label: stopwatches *)
	^ (if model.has_stopwatches then (
		let stopwatches = model.stopwatches automaton_index location_index in
		"|" ^
		(if stopwatches != [] then "stop " ^ string_of_list_of_variables model.variable_names stopwatches else "")
	) else "")
	
	(* The end *)
	^ "}\"];"
	
	(* Transitions *)
	^ (string_of_transitions model automaton_index location_index)
	
(*	
	^ 
	^ (match model.costs automaton_index location_index with
		| None -> ""
		| Some cost -> "[" ^ (LinearConstraint.string_of_linear_term model.variable_names cost) ^ "]"
	)
	^ ": "
	^ (string_of_invariant model automaton_index location_index)
	^ (string_of_transitions model automaton_index location_index)*)


(* Convert the locations of an automaton into a string *)
let string_of_locations model automaton_index =
	string_of_list_of_string_with_sep "\n " (List.map (fun location_index ->
		string_of_location model automaton_index location_index
	) (model.locations_per_automaton automaton_index))


(* Convert an automaton into a string *)
let string_of_automaton model automaton_index =
	(* Finding the initial location *)
	let inital_global_location  = model.initial_location in
	let initial_location = Automaton.get_location inital_global_location automaton_index in

	"\n/**************************************************/"
	^ "\n/* automaton " ^ (model.automata_names automaton_index) ^ " */"
	^ "\n/**************************************************/"
	
	(* Handling the initial arrow *)
	^ "\n init" ^ (string_of_int automaton_index) ^ "[shape=none, label=\"" ^ (model.automata_names automaton_index) ^ "\"];"
	^ "\n init" ^ (string_of_int automaton_index) ^ " -> " ^ (id_of_location automaton_index initial_location) ^ ";"

	(* Handling transitions *)
	^ "\n " ^ (string_of_locations model automaton_index)
	^ "\n/**************************************************/"


(* Convert the automata into a string *)
let string_of_automata model =
	(* Retrieve the input options *)
	let options = Input.get_options () in
	
	let vertical_string_of_list_of_variables variables =
		let variables = List.map model.variable_names variables in
		string_of_list_of_string_with_sep "\\n" variables
	in

	
	"\n/**************************************************/"
	^ "\n/* Starting general graph */"
	^ "\n/**************************************************/"
	^ "\n digraph G {\n"
	^ "\n node [shape=Mrecord, fontsize=12];"
(* 	^ "\n rankdir=LR" *)
	^ "\n"
	(* General information *)
(* 	s_0[fillcolor=red, style=filled, shape=Mrecord, label="s_0|{InputInit|And111|Or111}"]; *)
^ "\nname[shape=none, style=bold, fontsize=24, label=\"" ^ options#file ^ "\"];"
	^ "\ngeneral_info[shape=record, label=\"" (*Model|{*)
	^ "{Clocks|" ^ (vertical_string_of_list_of_variables model.clocks) ^ "}"
	^ "|{Parameters|" ^ (vertical_string_of_list_of_variables model.parameters) ^ "}"
	^ (if model.discrete != [] then
		"|{Discrete|" ^ (vertical_string_of_list_of_variables model.discrete) ^ "}"
		else "")
	^ "|{Initial|" ^ (escape_string_for_dot (LinearConstraint.string_of_px_linear_constraint model.variable_names model.initial_constraint)) ^ "}"
	^ "\"];" (*}*)
(* 	^ "\ngenerator[shape=none, style=bold, fontsize=10, label=\"Generated by " ^ (ImitatorUtilities.program_name_and_version_and_build()) ^ "\"];" *)
(* 	^ "\ndate[shape=none, style=bold, fontsize=10, label=\"Generation time: " ^ (now()) ^ "\"];" *)
		(* Version and generation time infos *)
		^ "\ngeneration[rotation=90.0, shape=rectangle, fontsize=10, label=\"Generated by " ^ (ImitatorUtilities.program_name_and_version_and_build()) ^ "
Generation time: " ^ (now()) ^ "\"];"
		(* To ensure the vertical ordering *)
	^ "\n name -> generation [color=white];"
	^ "\n generation -> general_info [color=white];"

	
	^ (string_of_list_of_string_with_sep "\n\n" (
		List.map (fun automaton_index -> string_of_automaton model automaton_index
	) model.automata))
	^ "\n\n/**************************************************/"
	^ "\n/* Ending general graph */"
	^ "\n/**************************************************/"
	^ "\n}"

(* Convert an automaton into a string *)
let string_of_model model =
	string_of_header model
(* 	^  "\n" ^ string_of_declarations model *)
	^  "\n" ^ string_of_automata model


(**************************************************)
(** Pi0 *)
(**************************************************)
(* Convert a pi0 into a string *)
let string_of_pi0 model pi0 =
	"  " ^ (
	string_of_list_of_string_with_sep "\n& " (
		List.map (fun parameter ->
			(model.variable_names parameter)
			^ " = "
			^ (NumConst.string_of_numconst (pi0 parameter))
		) model.parameters
	)
	)



(**************************************************************)
(* Result *)
(**************************************************************)
let string_of_returned_constraint variable_names = function 
	| Convex_constraint (linear_constraint , _) -> LinearConstraint.string_of_p_linear_constraint variable_names linear_constraint

	(** Disjunction of constraints *)
	| Union_of_constraints (k_list,_) -> string_of_list_of_string_with_sep "\n OR \n" (List.map (LinearConstraint.string_of_p_linear_constraint variable_names) k_list)
	
	| NNCConstraint _ -> raise (InternalError ("NNCCs are not available everywhere yet."))

